module vGrid_Descriptors

   ! Autor of C version : Andre Plante
   !                      Based on fortran version from:
   !                      Ron MacTaggart-Cowan, Andre Plante and Cecilien Charette

   ! Naming convention
   !
   ! var_8  is of type real*8
   ! var_L  is of type logical
   ! var_CP is of type type(c_prt) from iso_c_binging

   use iso_c_binding, only : c_ptr, C_NULL_PTR, C_CHAR, C_NULL_CHAR, c_associated, c_loc
   
   implicit none
   private
   
   ! Public methods
   public :: vgrid_descriptor                    !vertical grid descriptor structure
   public :: vgd_free                            !class destructor
   public :: vgd_get                             !get instance variable value
   public :: vgd_put                             !set instance variable value
   public :: vgd_new                             !class constructor
   public :: vgd_putopt                          !set class variable value
   public :: vgd_print                           !dump plain-text contents of instance
   public :: vgd_write                           !write coordinates to a file
   public :: operator(==)                        !overload equivalence operator

   ! Public class constants
#include "vgrid.hf"

   ! Private class variables
   logical :: ALLOW_RESHAPE=.false.              ! Allow reshape of class pointer members
   integer, parameter :: KEY_LENGTH=4            !length of key string considered for get/put operations
   character(len=1) :: one_char                  !character mold for tranfer function

   type :: vgrid_descriptor
      ! The only member of this type is a C pointer
      type(c_ptr) :: cptr = C_NULL_PTR
   end type vgrid_descriptor
   
   interface

      integer function f_get_int(vgd_CP, key, value_CP, quiet_CP) bind(c, name='Cvgd_get_int')
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr), value :: value_CP
         character(kind=c_char) :: key(*)
      end function f_get_int
     
      integer function f_get_int_1d(vgd_CP, key, value_CP, nk_CP, quiet_CP) bind(c, name='Cvgd_get_int_1d')
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr) :: value_CP
         type(c_ptr), value :: nk_CP
         character(kind=c_char) :: key(*)
      end function f_get_int_1d
   
      integer function f_get_real(vgd_CP, key, value_CP, quiet_CP) bind(c, name='Cvgd_get_real')
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr), value :: value_CP
         character(kind=c_char) :: key(*)
      end function f_get_real
      
      integer function f_get_real_1d(vgd_CP, key, value_CP, nk_CP, quiet_CP) bind(c, name='Cvgd_get_real_1d')
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr) :: value_CP
         type(c_ptr), value :: nk_CP
         character(kind=c_char) :: key(*)
      end function f_get_real_1d

      integer function f_get_real8(vgd_CP, key, value_CP, quiet_CP) bind(c, name='Cvgd_get_real8')
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr), value :: value_CP
         character(kind=c_char) :: key(*)
      end function f_get_real8

      integer function f_get_real8_1d(vgd_CP, key, value_CP, nk_CP, quiet_CP) bind(c, name='Cvgd_get_real8_1d')
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr) :: value_CP
         type(c_ptr), value :: nk_CP
         character(kind=c_char) :: key(*)
      end function f_get_real8_1d

      integer function f_get_real8_3d(vgd_CP, key, value_CP, ni_CP, nj_CP, nk_CP, quiet_CP) bind(c, name='Cvgd_get_real8_3d')
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr) :: value_CP
         type(c_ptr), value :: ni_CP, nj_CP, nk_CP
         character(kind=c_char) :: key(*)
      end function f_get_real8_3d
      
      integer function f_put_int(vgd_CP, key, value) bind(c, name='Cvgd_put_int')
         use iso_c_binding, only: c_ptr, c_char, c_int
         type(c_ptr) :: vgd_CP
         integer (c_int), value :: value
         character(kind=c_char) :: key(*)
      end function f_put_int

      integer function f_put_real8(vgd_CP, key, value) bind(c, name='Cvgd_put_real8')
         use iso_c_binding, only: c_ptr, c_char, c_double
         type(c_ptr) :: vgd_CP
         real (c_double), value :: value
         character(kind=c_char) :: key(*)
      end function f_put_real8

      integer function f_is_valid(vgd_CP, valid_table_name) bind(c, name='Cvgd_is_valid')
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP
         character(kind=c_char) :: valid_table_name(*)
      end function f_is_valid

      integer function f_print_desc(vgd_CP, stdout_CP, convip_CP) bind(c, name='Cvgd_print_desc')
         use iso_c_binding, only : c_ptr
         type(c_ptr), value :: vgd_CP, stdout_CP, convip_CP
      end function f_print_desc

      !integer function f_set_vcode_i(vgd_CP, kind, version) bind(c, name='Cvgd_set_vcode_i')
      !   use iso_c_binding, only : c_ptr, c_int
      !   type(c_ptr), value :: vgd_CP
      !   integer (c_int), value :: kind, version
      !end function f_set_vcode_i

      integer function f_vgdcmp(vgd1_CP, vgd2_CP) bind(c, name='Cvgd_vgdcmp')
         use iso_c_binding, only: c_ptr
         type(c_ptr), value :: vgd1_CP, vgd2_CP
      end function f_vgdcmp

      integer function f_new_read(vgd,unit,format,ip1_CP,ip2_CP,kind_CP,version_CP) bind(c, name='Cvgd_new_read')
         use iso_c_binding, only : c_ptr, c_int, c_char
         type(c_ptr) :: vgd
         integer (c_int), value :: unit
         character(kind=c_char) :: format(*)
         type(c_ptr), value :: ip1_CP,ip2_CP,kind_CP,version_CP
      end function f_new_read
      
      integer function f_new_from_table(vgd, table_CP, ni, nj, nk) bind(c, name='Cvgd_new_from_table')
         use iso_c_binding, only : c_ptr, c_int
         type(c_ptr) :: vgd
         type(c_ptr), value :: table_CP
         integer (c_int), value :: ni, nj, nk
      end function f_new_from_table

      integer function f_new_gen(vgd,kind,version,hyb_CP,size_hyb,rcoef1_CP,rcoef2_CP,ptop_8_CP,pref_8_CP,ptop_out_8_CP, &
           ip1,ip2,stdout_unit_CP,dhm_CP,dht_CP) bind(c, name='Cvgd_new_gen')
         use iso_c_binding, only : c_ptr, c_int
         type(c_ptr) :: vgd
         integer (c_int), value :: kind, version, size_hyb
         type(c_ptr), value :: hyb_CP,rcoef1_CP,rcoef2_CP,ptop_8_CP,pref_8_CP,ptop_out_8_CP
         type(c_ptr), value :: stdout_unit_CP,dhm_CP,dht_CP
         integer (c_int), value :: ip1,ip2
      end function f_new_gen
      
      integer function f_new_build_vert(vgd,kind,version,nk,ip1,ip2, &
           ptop_8_CP, pref_8_CP, rcoef1_CP, rcoef2_CP, &
           a_m_8_CP, b_m_8_CP, a_t_8_CP, b_t_8_CP, ip1_m_CP, ip1_t_CP, nl_m, nl_t) bind(c, name='Cvgd_new_build_vert')         
         use iso_c_binding, only : c_ptr, c_int
         type(c_ptr) :: vgd
         integer (c_int), value :: kind,version,nk,ip1,ip2
         type(c_ptr), value :: ptop_8_CP, pref_8_CP, rcoef1_CP, rcoef2_CP
         type(c_ptr), value :: a_m_8_CP, b_m_8_CP, a_t_8_CP, b_t_8_CP, ip1_m_CP, ip1_t_CP
         integer (c_int), value :: nl_m, nl_t
      end function f_new_build_vert

      subroutine f_vgd_free(vgd_CP) bind(c, name='Cvgd_vgd_free')
         use iso_c_binding, only : c_ptr
         type(c_ptr) :: vgd_CP
      end subroutine f_vgd_free
      
      subroutine f_table_shape(vgd_CP, tshape_CP) bind(c, name='Cvgd_table_shape')
         use iso_c_binding, only : c_ptr
         type(c_ptr), value :: vgd_CP
         type(c_ptr) :: tshape_CP
      end subroutine f_table_shape
         
      integer function f_write_desc(vgd_CP,unit,format) bind(c, name='Cvgd_write_desc')
         use iso_c_binding, only : c_ptr, c_int, c_char
         type(c_ptr), value :: vgd_CP
         integer (c_int), value :: unit
         character(kind=c_char) :: format(*)
      end function f_write_desc

   end interface
   
   interface vgd_new
      module procedure new_read
      module procedure new_from_table
      module procedure new_build_vert
      module procedure new_gen      
   end interface vgd_new

   interface vgd_free
      module procedure garbage_collection
   end interface vgd_free

   interface vgd_get
      module procedure get_int
      module procedure get_int_1d
      module procedure get_real
      module procedure get_real_1d
      module procedure get_real8
      module procedure get_real8_1d
      module procedure get_real8_3d
      !module procedure get_char
      !module procedure get_logical
   end interface vgd_get

   interface vgd_put
      module procedure put_int
      !module procedure put_int_1d
      !module procedure put_real_1d
      module procedure put_real8
      !module procedure put_real8_1d
      !module procedure put_real8_3d
      !module procedure put_char
   end interface vgd_put

   interface vgd_putopt
      module procedure putopt_logical
   end interface vgd_putopt
   
   interface vgd_print
      module procedure print_desc
   end interface vgd_print
   
   interface vgd_write
      module procedure write_desc
   end interface vgd_write

   interface operator (==)
      module procedure test_equality
   end interface operator (==)
   
contains
   
   integer function new_read(self,unit,format,ip1,ip2,kind,version) result(status)
      use utils, only: up
      ! Coordinate constructor - read from a file and initialize instance
      type(vgrid_descriptor), intent(inout) :: self !Vertical descriptor instance
      integer, intent(in) :: unit                 !File unit to read descriptor information from
      character(len=*), target, optional, intent(in) :: format !File format ('fst' or 'bin') default is 'fst'
      integer, target,optional :: ip1,ip2                 !ip1,2 values of the desired descriptors
      integer, target,optional, intent(in) :: kind        ! Level kind requested by user.
      integer, target,optional, intent(in) :: version     ! Level version requested by user.
      
      ! Local variables
      character(len=100) :: myformat
      type(c_ptr) :: ip1_CP, ip2_CP, kind_CP, version_CP

      status = VGD_ERROR

      myformat='FST'
      if (present(format)) myformat = trim(up(format))
      if(present(ip1))then
         ip1_CP = c_loc(ip1)
      else
         ip1_CP = C_NULL_PTR
      endif
      if(present(ip2))then
         ip2_CP = c_loc(ip2)
      else
         ip2_CP = C_NULL_PTR
      endif
      if(present(kind))then
         kind_CP = c_loc(kind)
      else
         kind_CP = C_NULL_PTR
      endif
      if(present(version))then
         version_CP = c_loc(version)
      else
         version_CP = C_NULL_PTR
      endif

      if( f_new_read(self%cptr, unit, trim(myformat)//C_NULL_CHAR, ip1_CP, ip2_CP, kind_CP, version_CP) == VGD_ERROR )then
         print*,'(F_vgd) ERROR: In new_read, problem with f_new_read'
         return
      endif
      
      status = VGD_OK

   end function new_read

    integer function new_from_table(self,table) result(status)
       ! Coordinate constructor - build vertical descriptor from table input
       ! Set internal vcode (if all above was successful)
       type(vgrid_descriptor), target, intent(inout) :: self !Vertical descriptor instance    
       real(kind=8), dimension(:,:,:), pointer :: table   !Raw table of vgrid records

       ! Local variables
       type(c_ptr) :: table_CP
       table_CP = c_loc(table)
       
       status = VGD_ERROR
       if ( f_new_from_table(self%cptr, table_CP, size(table,dim=1), size(table,dim=2), size(table,dim=3)) )then
         print*,'(F_vgd) ERROR: in new_from_table, problem with f_new_from_table'
         return
      endif      
      
      status = VGD_OK
      
    end function new_from_table

   integer function new_gen(self,kind,version,hyb,rcoef1,rcoef2,ptop_8,pref_8,ptop_out_8,ip1,ip2,stdout_unit,dhm,dht) result(status)
      implicit none

      ! Coordinate constructor - build vertical descriptor from hybrid coordinate entries
      type(vgrid_descriptor),target,intent(inout) :: self         !Vertical descriptor instance    
      integer, intent(in) :: kind,version                  !Kind,version to create
      real, target, dimension(:),intent(in) :: hyb         !List of hybrid levels
      real, target, optional, intent(in) :: rcoef1,rcoef2  !R-coefficient values for rectification
      real*8, target, optional, intent(in) :: ptop_8       !Top-level pressure (Pa) inout
      real*8, target, optional, intent(out):: ptop_out_8   !Top-level pressure (Pa) output if ptop_8 < 0
      real*8, target, optional, intent(in) :: pref_8       !Reference-level pressure (Pa)
      integer, target, optional, intent(in) :: ip1,ip2     !IP1,2 values for FST file record [0,0]
      integer, target, optional, intent(in) :: stdout_unit !Unit number for verbose output [STDERR]
      real, target, optional, intent(in) :: dhm,dht        !Diag levels Height for Momentum/Thermo vaiables
      
      ! Local variables
      type(c_ptr) :: hyb_CP, rcoef1_CP, rcoef2_CP, ptop_8_CP, ptop_out_8_CP, pref_8_CP
      type(c_ptr) :: stdout_unit_CP, dhm_CP, dht_CP
      integer :: my_ip1, my_ip2

      hyb_CP = c_loc(hyb)

      status = VGD_ERROR;
      ! Assign optional argument to C_NULL_PTR
      if(present(rcoef1))then
         rcoef1_CP = c_loc(rcoef1)
      else
         rcoef1_CP = C_NULL_PTR
      endif
      if(present(rcoef2))then
         rcoef2_CP = c_loc(rcoef2)
      else
         rcoef2_CP = C_NULL_PTR
      endif
      if(present(ptop_8))then
         ptop_8_CP = c_loc(ptop_8)
      else
         ptop_8_CP = C_NULL_PTR
      endif
      if(present(ptop_out_8))then
         ptop_out_8_CP = c_loc(ptop_out_8)
      else
         ptop_out_8_CP = C_NULL_PTR
      endif
      if(present(pref_8))then
         pref_8_CP = c_loc(pref_8)
      else
         pref_8_CP = C_NULL_PTR
      endif
      if(present(ip1))then
         my_ip1 = ip1
      else
         my_ip1 = -1
      endif
      if(present(ip2))then
         my_ip2 = ip2
      else
         my_ip2 = -1
      endif
      if(present(stdout_unit))then
         stdout_unit_CP = c_loc(stdout_unit)
      else
         stdout_unit_CP = C_NULL_PTR
      endif
      if(present(dhm))then
         dhm_CP = c_loc(dhm)
      else
         dhm_CP = C_NULL_PTR
      endif
      if(present(dht))then
         dht_CP = c_loc(dht)
      else
         dht_CP = C_NULL_PTR
      endif
      
      if(.not.c_associated(self%cptr))then
         self%cptr = C_NULL_PTR
      endif

      if(f_new_gen(self%cptr,kind,version,hyb_CP,size(hyb),rcoef1_CP,rcoef2_CP,ptop_8_CP,pref_8_CP,ptop_out_8_CP,my_ip1,my_ip2,stdout_unit_CP,dhm_CP,dht_CP) == VGD_ERROR)then
         print*,'(F_vgd) ERROR in new_gen, problem with f_new_gen'
         return
      endif
      status = VGD_OK;
   end function new_gen

   integer function new_build_vert(self,kind,version,nk,ip1,ip2, &
        ptop_8,pref_8,rcoef1,rcoef2,a_m_8,b_m_8,a_t_8,b_t_8, &
        ip1_m,ip1_t) result(status)
      ! Coordinate constructor - build vertical descriptor from arguments
      type(vgrid_descriptor) :: self                    !Vertical descriptor instance    
      integer, intent(in) :: kind,version               !Kind,version to create
      integer, intent(in) :: nk                         !Number of levels
      integer,target , optional, intent(in) :: ip1,ip2          !IP1,2 values for FST file record [0,0]
      real,target , optional, intent(in) :: rcoef1,rcoef2       !R-coefficient values for rectification
      real*8,target , optional, intent(in) :: ptop_8            !Top-level pressure (Pa)
      real*8,target , optional, intent(in) :: pref_8            !Reference-level pressure (Pa)
      real*8,target , optional, dimension(:) :: a_m_8,a_t_8     !A-coefficients for momentum(m),thermo(t) levels
      real*8,target , optional, dimension(:) :: b_m_8,b_t_8     !B-coefficients for momentum(m),thermo(t) levels
      integer,target , optional, dimension(:) :: ip1_m,ip1_t    !Level ID (IP1) for momentum(m),thermo(t) levels

      ! Assign optional argument to C_NULL_PTR    

      ! Local variables
      type(c_ptr) :: rcoef1_CP, rcoef2_CP, ptop_8_CP, pref_8_CP
      type(c_ptr) :: a_m_8_CP, b_m_8_CP, a_t_8_CP, b_t_8_CP, ip1_m_CP, ip1_t_CP
      integer l_ip1,l_ip2,nl_m, nl_t

      status = VGD_ERROR

      nl_m=nk
      nl_t=-1

      if(present(ip1))then
         l_ip1 = ip1
      else
         l_ip1 = -1
      endif
      if(present(ip2))then
         l_ip2 = ip2
      else
         l_ip2 = -1
      endif
      if(present(ptop_8))then
         ptop_8_CP = c_loc(ptop_8)
      else
         ptop_8_CP = C_NULL_PTR
      endif
      if(present(pref_8))then
         pref_8_CP = c_loc(pref_8)
      else
         pref_8_CP = C_NULL_PTR
      endif
      if(present(rcoef1))then
         rcoef1_CP = c_loc(rcoef1)
      else
         rcoef1_CP = C_NULL_PTR
      endif
      if(present(rcoef2))then
         rcoef2_CP = c_loc(rcoef2)
      else
         rcoef2_CP = C_NULL_PTR
      endif
      if(present(a_m_8))then
         a_m_8_CP = c_loc(a_m_8)
         nl_m = size(a_m_8)
      else
         a_m_8_CP = C_NULL_PTR
      endif
      if(present(b_m_8))then
         b_m_8_CP = c_loc(b_m_8)
      else
         b_m_8_CP = C_NULL_PTR
      endif
      if(present(a_t_8))then
         a_t_8_CP = c_loc(a_t_8)
         nl_t = size(a_t_8)
      else
         a_t_8_CP = C_NULL_PTR
      endif
      if(present(b_t_8))then
         b_t_8_CP = c_loc(b_t_8)
      else
         b_t_8_CP = C_NULL_PTR
      endif
      if(present(ip1_m))then
         ip1_m_CP = c_loc(ip1_m)
      else
         ip1_m_CP = C_NULL_PTR
      endif
      if(present(ip1_t))then
         ip1_t_CP = c_loc(ip1_t)
      else
         ip1_t_CP = C_NULL_PTR
      endif
      if( f_new_build_vert(self%cptr,kind,version,nk,l_ip1,l_ip2, &
           ptop_8_CP, pref_8_CP, rcoef1_CP, rcoef2_CP, &
           a_m_8_CP, b_m_8_CP, a_t_8_CP, b_t_8_CP, ip1_m_CP, ip1_t_CP, nl_m, nl_t) == VGD_ERROR )then
         print*,'(F_vgd) ERROR in new_build_vert, problem with c_new_build_vert',VGD_ERROR
         return
      endif

      status = VGD_OK

   end function new_build_vert

   integer function garbage_collection(self) result(status)
      type(vgrid_descriptor) :: self
      call f_vgd_free(self%cptr)
      status = VGD_OK
   end function garbage_collection

   integer function putopt_logical(key,value) result(status)
      character(len=*), intent(in) :: key           !Descriptor key to retrieve
      logical, intent(in) :: value                    !Retrieved value
      
      ! Local variables
      
      ! Set error status
      status=VGD_ERROR
      
      select case(trim(key))
      case ('ALLOW_RESHAPE')
         ALLOW_RESHAPE=value
      case DEFAULT
         write(for_msg,*) 'invalid key in call to putopt_logical: ',trim(key)
         call msg(MSG_ERROR,VGD_PRFX//for_msg)
         return
      end select
      ! Set status and return
      status = VGD_OK
      return
   end function putopt_logical
   
   logical function test_equality(vgd1,vgd2) result(equal)
      type(vgrid_descriptor), intent(in) :: vgd1,vgd2      !vertical grid descriptors to compare

      ! Local variables
      integer :: ier

      ! Assume that structures are not identical
      equal = .false.
      
      ier = f_vgdcmp(vgd1%cptr, vgd2%cptr)
      if( ier /= 0 )then
         print*,'(F_vgd) Descriptor not equal, ier=',ier
         return
      end if

      ! The full structure is equivalent
      equal = .true.
      return
   end function test_equality

   integer function print_desc(self,stdout,convip_L) result(istat)      
      type(vgrid_descriptor) :: self
      integer, target, intent(in), optional :: stdout     !Output unit to write to [6]
      logical, intent(in), optional :: convip_L

      ! Internal variables
      type(c_ptr) :: stdout_CP, convip_CP
      integer, target :: zero, one

      zero = 0; one = 1;

      istat = VGD_ERROR
      if(.not.c_associated(self%cptr))then
         print*,'(F_vgd) ERROR in print_descript, self%cptr not associated'
         return
      endif

      stdout_CP = C_NULL_PTR
      convip_CP = C_NULL_PTR
      if(present(stdout)) stdout_CP = c_loc(stdout)
      if(present(convip_L))then
         if(convip_L)convip_CP = c_loc(one)
      endif

      istat = f_print_desc(self%cptr,stdout_CP,convip_CP)
   end function print_desc

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Write descriptors
   
   integer function write_desc(self,unit,format) result(status)     
      use utils, only: up
      ! Write descriptors to the requested file
      type(vgrid_descriptor), intent(in) :: self       !Vertical descriptor instance
      integer, intent(in) :: unit                      !File unit to write to
      character(len=*), optional, intent(in) :: format !File format ('fst' or 'bin' ) default is 'fst'

      ! Local variables
      integer ier
      character(len=100) :: myformat

      ! Set error status
      status = VGD_ERROR
      myformat='FST'
      if (present(format)) myformat = trim(up(format))

      if( f_write_desc(self%cptr,unit,trim(myformat)//C_NULL_CHAR)  == VGD_ERROR )then
         print*,'(F_vgd) ERROR: In write_desc, problem with f_write_desc'
         return
      endif

     ! Set status and return
      status = VGD_OK
      return
   end function write_desc

   integer function get_int(self,key,value,quiet) result(status)
       use utils, only: up
      ! Retrieve the value of the requested instance variable
      type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
      character(len=*), intent(in) :: key                 !Descriptor key to retrieve
      integer,target, intent(out) :: value                !Retrieved value
      logical, optional, intent(in) :: quiet              !Do not print massages
      
      ! Internal variables
      type(c_ptr) :: quiet_CP, value_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: zero, one

      zero = 0; one = 1
      
      quiet_CP = C_NULL_PTR
      if (present(quiet))then
         if(quiet) then
            quiet_CP = c_loc(one)
         else
            quiet_CP = c_loc(zero)
         endif         
      endif

      value_CP = c_loc(value)
      my_key=up(key(1:KEY_LENGTH))
      status = f_get_int(self%cptr,my_key//C_NULL_CHAR, value_CP, quiet_CP)
      
   end function get_int
 
   integer function get_int_1d(self,key,value,quiet) result(status)
      use utils, only: get_allocate,up,get_error
      ! Retrieve the value of the requested instance variable
      type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
      character(len=*), intent(in) :: key                 !Descriptor key to retrieve
      integer, dimension(:), pointer :: value             !Retrieved value
      logical, optional, intent(in) :: quiet              !Do not print massages
      
      ! Internal variables
      integer :: nl_, istat, level_msg, error
      type(c_ptr) :: quiet_CP, value_CP, nk_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: zero, one, nk

      zero = 0; one = 1
      nk_CP = c_loc(nk)

      ! Set error status
      status = VGD_ERROR
      
      level_msg=MSG_ERROR
      if(.not. is_valid(self,'SELF')) then
         write(for_msg,*) 'vgrid structure is not valid in get_int_1d'
         call msg(MSG_ERROR,VGD_PRFX//for_msg)       
         return
      endif

      quiet_CP = C_NULL_PTR
      if (present(quiet))then
         if(quiet) then
            level_msg=MSG_QUIET
            quiet_CP = c_loc(one)
         else
            quiet_CP = c_loc(zero)
         endif         
      endif
      
      my_key=up(key(1:KEY_LENGTH))

      ! Map key name to derived-type element
      select case (my_key)
      case ('VIPM','VIP1')
         if (is_valid(self,"ip1_m_valid")) then
            istat = get_int(self,'NL_M',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(VIPM in get_int_1d)')
            if (istat /= 0) return
            value_CP = c_loc(value(1))            
            status = f_get_int_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,nk_CP,quiet_CP)
         else
            error = int(get_error(key))
            return
         endif
      case ('VIPT')
         if (is_valid(self,"ip1_t_valid_get")) then
            istat = get_int(self,'NL_T',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(VIPT in get_int_1d)')
            if (istat /= 0) return
            value_CP = c_loc(value(1))
            status = f_get_int_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,nk_CP,quiet_CP)
         else
            error = int(get_error(key))
            return
         endif
      case DEFAULT
         write(for_msg,*) 'invalid key '//trim(key)//' given to gd_get (int 1D)'
         call msg(level_msg,VGD_PRFX//for_msg)
         return
      end select
      
      return
      
   end function get_int_1d
   
   integer function get_real(self,key,value,quiet) result(status)
      use utils, only: up
      ! Retrieve the value of the requested instance variable
      type(vgrid_descriptor), intent(in) :: self     !Vertical descriptor instance
      character(len=*), intent(in) :: key            !Descriptor key to retrieve
      real, target, intent(out) :: value             !Retrieved value
      logical, target, optional, intent(in) :: quiet !Do not print massages
      
      ! Internal variables
      type(c_ptr) :: quiet_CP, value_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: zero, one

      zero = 0; one = 1

      value = VGD_MISSING      

      quiet_CP = C_NULL_PTR
      if (present(quiet))then
         if(quiet) then
            quiet_CP = c_loc(one)
         else
            quiet_CP = c_loc(zero)
         endif         
      endif
      
      value_CP = c_loc(value)
      my_key=up(key(1:KEY_LENGTH))
      status = f_get_real(self%cptr,my_key//C_NULL_CHAR,value_CP,quiet_CP)
      
      return
   end function get_real
  

   integer function get_real_1d(self,key,value,quiet) result(status)
      use utils, only: get_allocate,up,get_error
      ! Retrieve the value of the requested instance variable
      type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
      character(len=*), intent(in) :: key         !Descriptor key to retrieve
      real, dimension(:), pointer :: value        !Retrieved value
      logical, optional, intent(in) :: quiet      !Do not print massages

      ! Internal variables
      integer :: istat,error,level_msg,k,kind,nl_
      integer, dimension(:), pointer :: vipt
      type(c_ptr) :: quiet_CP, value_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: zero, one

      zero = 0; one = 1

      ! Set error status
      status = VGD_ERROR
      
      nullify(vipt)
      
      level_msg=MSG_ERROR
      if(.not. is_valid(self,'SELF')) then
         write(for_msg,*) 'vgrid structure is not valid in get_real_1d'
         call msg(MSG_ERROR,VGD_PRFX//for_msg)
         return
      endif
      quiet_CP = C_NULL_PTR
      if (present(quiet))then
         if(quiet) then
            level_msg=MSG_QUIET
            quiet_CP = c_loc(one)
         else
            quiet_CP = c_loc(zero)
         endif         
      endif
      
      my_key=up(key(1:KEY_LENGTH))
      
      ! Map key name to derived-type element
      select case (my_key)
      case ('VCDM')
         if (is_valid(self, "ip1_m_valid")) then
            istat = get_int(self,'NL_M',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(VCDM in get_real_1d)')
            if (istat /= 0) return
            value_CP = c_loc(value(1))
            istat = f_get_real_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,C_NULL_PTR,quiet_CP)
            if (istat == VGD_ERROR) return
         else
            error = int(get_error(key))
            return
         endif
      case ('VCDT')
         if (is_valid(self, "ip1_t_valid_get")) then
            istat = get_int(self,'NL_T',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(VCDT in get_real_1d)')
            if (istat /= 0) return
            value_CP = c_loc(value(1))
            istat = f_get_real_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,C_NULL_PTR,quiet_CP)
            if (istat == VGD_ERROR) return
         else
            error = int(get_error(key))
            return
         endif
      case ('VCRD')
         if (is_valid(self,"ip1_m_valid")) then
            write(for_msg,*) 'depricated key '//trim(key)//', use VCDM instead'
            call msg(level_msg,VGD_PRFX//for_msg)
            return
         else
            error = int(get_error(key))
            return
         endif
      case DEFAULT
         write(for_msg,*) 'invalid key '//trim(key)//' given to gd_get (real 1D)'
         call msg(level_msg,VGD_PRFX//for_msg)
         return
      end select
      
      ! Set status and return
      status = VGD_OK
      return
   end function get_real_1d
   
   integer function get_real8(self,key,value,quiet) result(status)
      use utils, only: up
      type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
      character(len=*), intent(in) :: key         !Descriptor key to retrieve
      real(kind=8), target, intent(out) :: value  !Retrieved value
      logical, optional, intent(in) :: quiet      !Do not print massages

      ! Internal variables
      type(c_ptr) :: quiet_CP, value_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: zero, one

      zero = 0; one = 1
      ! Set error status
      status = VGD_ERROR
      
      value = VGD_MISSING
      
      quiet_CP = C_NULL_PTR
      if (present(quiet))then
         if(quiet) then
            quiet_CP = c_loc(one)
         else
            quiet_CP = c_loc(zero)
         endif         
      endif
      
      value_CP = c_loc(value)
      my_key=up(key(1:KEY_LENGTH))
      status = f_get_real8(self%cptr,my_key//C_NULL_CHAR,value_CP,quiet_CP)
      
   end function get_real8

   integer function get_real8_1d(self,key,value,quiet) result(status)
      use utils, only: get_allocate,up,get_error
      ! Wrapper function to C f_get_real8_1d
      type(vgrid_descriptor), intent(in) :: self     !Vertical descriptor instance
      character(len=*), intent(in) :: key            !Descriptor key to retrieve
      real(kind=8), dimension(:), pointer :: value   !Retrieved value
      logical, target, optional, intent(in) :: quiet !Do not print massages
      
      ! Internal variables
      integer :: nl_, istat, level_msg, error
      type(c_ptr) :: quiet_CP, value_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: zero, one

      zero = 0; one = 1

      status = VGD_ERROR

      level_msg=MSG_ERROR
      if(.not. is_valid(self,'SELF')) then
         write(for_msg,*) 'vgrid structure is not valid in get_real8_1d'
         call msg(MSG_ERROR,VGD_PRFX//for_msg)       
         return
      endif
      quiet_CP = C_NULL_PTR
      if (present(quiet))then
         if(quiet) then
            level_msg=MSG_QUIET
            quiet_CP = c_loc(one)
         else
            quiet_CP = c_loc(zero)
         endif         
      endif

      my_key=up(key(1:KEY_LENGTH))

      select case (my_key)
      case ('CA_M','COFA')
         if (is_valid(self,"a_m_8_valid")) then
            istat = get_int(self,'NL_M',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(CA_M in get_real8_1d)')         
            if (istat /= 0) return
            value_CP = c_loc(value(1))
            status = f_get_real8_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,C_NULL_PTR,quiet_CP)
         else
            error = int(get_error(key))
            return
         endif
      case ('CB_M','COFB')
         if (is_valid(self,"b_m_8_valid")) then
            istat = get_int(self,'NL_M',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(CB_M in get_real8_1d)')         
            if (istat /= 0) return
            value_CP = c_loc(value(1))
            status = f_get_real8_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,C_NULL_PTR,quiet_CP)
         else
            error = int(get_error(key))
            return
         endif
      case ('CA_T')
         if (is_valid(self,"a_t_8_valid_get")) then
            istat = get_int(self,'NL_T',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(CA_T in get_real8_1d)')         
            if (istat /= 0) return
            value_CP = c_loc(value(1))
            status = f_get_real8_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,C_NULL_PTR,quiet_CP)            
         else
            error = int(get_error(key))
            return
         endif
      case ('CB_T')
         if (is_valid(self,"b_t_8_valid_get")) then
            istat = get_int(self,'NL_T',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(CB_T in get_real8_1d)')         
            if (istat /= 0) return
            value_CP = c_loc(value(1))
            status = f_get_real8_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,C_NULL_PTR,quiet_CP)
         else
            error = int(get_error(key))
            return
         endif
      case DEFAULT
         write(for_msg,*) 'invalid key '//trim(key)//' given to gd_get (real8 1D)'
         call msg(level_msg,VGD_PRFX//for_msg)
         return
      end select
      return      
   end function get_real8_1d

   integer function get_real8_3d(self,key,value,quiet) result(status)
      use utils, only: get_allocate,up
      ! Retrieve the value of the requested instance variable
      type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
      character(len=*), intent(in) :: key         !Descriptor key to retrieve
      real(kind=8), dimension(:,:,:), pointer :: value !Retrieved value
      logical, optional, intent(in) :: quiet      !Do not print massages

      ! Internal variables
      integer :: istat,level_msg
      integer, target, dimension(3) :: tshape
      type(c_ptr) :: quiet_CP, value_CP, tshape_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: zero, one

      zero = 0; one = 1

      ! Set error status
      status = VGD_ERROR
      
      level_msg=MSG_ERROR
      if(.not. is_valid(self,'SELF'))then
         write(for_msg,*) 'vgrid structure is not valid in get_real8_3d'
         call msg(MSG_ERROR,VGD_PRFX//for_msg)       
         return
      endif
      quiet_CP = C_NULL_PTR
      if (present(quiet))then
         if(quiet) then
            level_msg=MSG_QUIET
            quiet_CP = c_loc(one)
         else
            quiet_CP = c_loc(zero)
         endif         
      endif
       
      my_key=up(key(1:KEY_LENGTH))
      
      ! Map key name to derived-type element
      select case (my_key)
      case ('VTBL')
         tshape_CP = c_loc(tshape)
         call f_table_shape(self%cptr, tshape_CP)
         istat = get_allocate(key,value,tshape,ALLOW_RESHAPE,'(VTBL) in get_real8_3d)')         
         if (istat /= 0) return
         value_CP = c_loc(value(1,1,1))
         status = f_get_real8_3d(self%cptr,"VTBL"//C_NULL_CHAR,value_CP,C_NULL_PTR,C_NULL_PTR,C_NULL_PTR,quiet_CP)         
      case DEFAULT
         write(for_msg,*) 'invalid key '//trim(key)//' given to gd_get (real8 3D)'
         call msg(level_msg,VGD_PRFX//for_msg)
         return
      end select
      
      ! Set status and return
      status = VGD_OK
      return
   end function get_real8_3d
    
   integer function put_int(self, key, value) result(status)
      use utils, only : up
      type(vgrid_descriptor), intent(inout) :: self !Vertical descriptor instance
      character(len=*), intent(in) :: key           !Descriptor key to set
      integer, target, intent(in) :: value          !Value to set

      ! Internal variables
      character(len=KEY_LENGTH) :: my_key

      my_key = up(key(1:KEY_LENGTH))
      status = f_put_int(self%cptr, trim(my_key)//C_NULL_CHAR, value)
   end function put_int

   integer function put_real8(self, key, value) result(status)
      use utils, only : up
      type(vgrid_descriptor), intent(inout) :: self !Vertical descriptor instance
      character(len=*), intent(in) :: key           !Descriptor key to set
      real(kind=8), target, intent(in) :: value     !Value to set

      ! Internal variables
      character(len=KEY_LENGTH) :: my_key

      my_key = up(key(1:KEY_LENGTH))
      status = f_put_real8(self%cptr, trim(my_key)//C_NULL_CHAR, value)
      
   end function put_real8

   logical function is_valid(self,element_valid_S) result(valid)
      ! Check for validity of the element
      type(vgrid_descriptor) :: self          !Vertical descriptor instance
      character(len=*) :: element_valid_S
      valid =  f_is_valid(self%cptr,element_valid_S//C_NULL_CHAR) == 1
      return
   end function is_valid
      
end module vGrid_Descriptors

