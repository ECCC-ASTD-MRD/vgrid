module vGrid_Descriptors

   ! Autor of C version : Andre Plante
   !                      Based on fortran version from:
   !                      Ron MacTaggart-Cowan, Andre Plante and Cecilien Charette

   ! Naming convention
   !
   ! var_8  is of type real*8
   ! var_L  is of type logical
   ! var_CP is of type type(c_prt) from iso_c_binging

   use iso_c_binding, only : c_ptr, C_NULL_PTR, C_CHAR, C_NULL_CHAR, c_associated, c_loc
   
   implicit none
   private
   
   ! Public methods
   public :: vgrid_descriptor                    !vertical grid descriptor structure
   public :: vgd_free                            !class destructor
   public :: vgd_get                             !get instance variable value
   public :: vgd_new                             !class constructor
   public :: vgd_putopt                          !set class variable value
   public :: vgd_print                           !dump plain-text contents of instance

   ! Public class constants
#include "vgrid.hf"

   ! Private class variables
   logical :: ALLOW_RESHAPE=.false.              ! Allow reshape of class pointer members
   integer, parameter :: KEY_LENGTH=4            !length of key string considered for get/put operations

   type vgrid_descriptor
      ! The only member of this type is a C pointer
      type(c_ptr) :: cptr
   end type vgrid_descriptor
   
   interface

      type(c_ptr) function c_vgd_construct () bind(c)
         use iso_c_binding, only : c_ptr
      end function c_vgd_construct

      integer function c_get_int(vgd_CP, key, value_CP, quiet_CP) bind(c)
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr) :: value_CP
         character(kind=c_char) :: key(*)
      end function c_get_int
     
      integer function c_get_int_1d(vgd_CP, key, value_CP, quiet_CP) bind(c)
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr) :: value_CP
         character(kind=c_char) :: key(*)
      end function c_get_int_1d
   
      integer function c_get_real(vgd_CP, key, value_CP, quiet_CP) bind(c)
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr) :: value_CP
         character(kind=c_char) :: key(*)
      end function c_get_real

      integer function c_get_real8_1d(vgd_CP, key, value_CP, quiet_CP) bind(c)
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr) :: value_CP
         character(kind=c_char) :: key(*)
      end function c_get_real8_1d

      integer function c_get_real8_3d(vgd_CP, key, value_CP, quiet_CP) bind(c)
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP, quiet_CP
         type(c_ptr) :: value_CP
         character(kind=c_char) :: key(*)
      end function c_get_real8_3d
   
      integer function c_is_valid(vgd_CP, valid_table_name) bind(c)
         use iso_c_binding, only: c_ptr, c_char
         type(c_ptr), value :: vgd_CP
         character(kind=c_char) :: valid_table_name(*)
      end function c_is_valid

      integer function c_print_desc(vgd_CP, stdout_CP, convip_CP) bind(c)
         use iso_c_binding, only : c_ptr
         type(c_ptr), value :: vgd_CP, stdout_CP, convip_CP
      end function c_print_desc

      integer function c_set_vcode_i(vgd_CP, kind, version) bind(c)
         use iso_c_binding, only : c_ptr, c_int
         type(c_ptr), value :: vgd_CP
         integer (c_int), value :: kind, version
      end function c_set_vcode_i

      integer function c_new_gen(vgd,kind,version,hyb_CP,size_hyb,rcoef1_CP,rcoef2_CP,ptop_8_CP,pref_8_CP,ptop_out_8_CP, &
           ip1,ip2,stdout_unit_CP,dhm_CP,dht_CP) bind(c)
         use iso_c_binding, only : c_ptr, c_int
         type(c_ptr) :: vgd
         integer (c_int), value :: kind, version, size_hyb
         type(c_ptr), value :: hyb_CP,rcoef1_CP,rcoef2_CP,ptop_8_CP,pref_8_CP,ptop_out_8_CP
         type(c_ptr), value :: stdout_unit_CP,dhm_CP,dht_CP
         integer (c_int), value :: ip1,ip2
      end function c_new_gen
      
      integer function c_new_build_vert(vgd,kind,version,nk,ip1,ip2, &
           ptop_8_CP, pref_8_CP, rcoef1_CP, rcoef2_CP, &
           a_m_8_CP, b_m_8_CP, a_t_8_CP, b_t_8_CP, ip1_m_CP, ip1_t_CP, nl_m, nl_t) bind(c)         
         use iso_c_binding, only : c_ptr, c_int
         type(c_ptr) :: vgd
         integer (c_int), value :: kind,version,nk,ip1,ip2
         type(c_ptr), value :: ptop_8_CP, pref_8_CP, rcoef1_CP, rcoef2_CP
         type(c_ptr), value :: a_m_8_CP, b_m_8_CP, a_t_8_CP, b_t_8_CP, ip1_m_CP, ip1_t_CP
         integer (c_int), value :: nl_m, nl_t
      end function c_new_build_vert

      subroutine c_vgd_free(vgd_CP) bind(c)
         use iso_c_binding, only : c_ptr
         type(c_ptr) :: vgd_CP
      end subroutine c_vgd_free
      
      subroutine c_table_shape(vgd_CP, tshape_CP) bind(c)
         use iso_c_binding, only : c_ptr
         type(c_ptr), value :: vgd_CP
         type(c_ptr) :: tshape_CP
      end subroutine c_table_shape
         

   end interface
   
   interface vgd_new
      module procedure new_build_vert
      module procedure new_gen      
   end interface vgd_new

   interface vgd_free
      module procedure garbage_collection
   end interface vgd_free

   interface vgd_get
      module procedure get_int
      module procedure get_int_1d
      module procedure get_real
      module procedure get_real_1d
      !module procedure get_real8
      module procedure get_real8_1d
      module procedure get_real8_3d
      !module procedure get_char
      !module procedure get_logical
   end interface vgd_get

   interface vgd_putopt
      module procedure putopt_logical
   end interface vgd_putopt
   
   interface vgd_print
      module procedure print_desc
   end interface vgd_print
   
contains
   
   integer function new_gen(self,kind,version,hyb,rcoef1,rcoef2,ptop_8,pref_8,ptop_out_8,ip1,ip2,stdout_unit,dhm,dht) result(status)
      implicit none

      ! Coordinate constructor - build vertical descriptor from hybrid coordinate entries
      type(vgrid_descriptor),intent(inout) :: self         !Vertical descriptor instance    
      integer, intent(in) :: kind,version                  !Kind,version to create
      real, target, dimension(:),intent(in) :: hyb         !List of hybrid levels
      real, target, optional, intent(in) :: rcoef1,rcoef2  !R-coefficient values for rectification
      real*8, target, optional, intent(in) :: ptop_8       !Top-level pressure (Pa) inout
      real*8, target, optional, intent(out):: ptop_out_8   !Top-level pressure (Pa) output if ptop_8 < 0
      real*8, target, optional, intent(in) :: pref_8       !Reference-level pressure (Pa)
      integer, target, optional, intent(in) :: ip1,ip2     !IP1,2 values for FST file record [0,0]
      integer, target, optional, intent(in) :: stdout_unit !Unit number for verbose output [STDERR]
      real, target, optional, intent(in) :: dhm,dht        !Diag levels Height for Momentum/Thermo vaiables
      
      ! Local variables
      type(c_ptr) :: hyb_CP, rcoef1_CP, rcoef2_CP, ptop_8_CP, ptop_out_8_CP, pref_8_CP
      type(c_ptr) :: stdout_unit_CP, dhm_CP, dht_CP
      integer :: my_ip1, my_ip2

      hyb_CP = c_loc(hyb)

      status = VGD_ERROR;
      ! Assign optional argument to C_NULL_PTR
      if(present(rcoef1))then
         rcoef1_CP = c_loc(rcoef1)
      else
         rcoef1_CP = C_NULL_PTR
      endif
      if(present(rcoef2))then
         rcoef2_CP = c_loc(rcoef2)
      else
         rcoef2_CP = C_NULL_PTR
      endif
      if(present(ptop_8))then
         ptop_8_CP = c_loc(ptop_8)
      else
         ptop_8_CP = C_NULL_PTR
      endif
      if(present(ptop_out_8))then
         ptop_out_8_CP = c_loc(ptop_out_8)
      else
         ptop_out_8_CP = C_NULL_PTR
      endif
      if(present(pref_8))then
         pref_8_CP = c_loc(pref_8)
      else
         pref_8_CP = C_NULL_PTR
      endif
      if(present(ip1))then
         my_ip1 = ip1
      else
         my_ip1 = -1
      endif
      if(present(ip2))then
         my_ip2 = ip2
      else
         my_ip2 = -1
      endif
      if(present(stdout_unit))then
         stdout_unit_CP = c_loc(stdout_unit)
      else
         stdout_unit_CP = C_NULL_PTR
      endif
      if(present(dhm))then
         dhm_CP = c_loc(dhm)
      else
         dhm_CP = C_NULL_PTR
      endif
      if(present(dht))then
         dht_CP = c_loc(dht)
      else
         dht_CP = C_NULL_PTR
      endif
      
      if(.not.c_associated(self%cptr))then
         self%cptr = C_NULL_PTR
      endif
      if(c_new_gen(self%cptr,kind,version,hyb_CP,size(hyb),rcoef1_CP,rcoef2_CP,ptop_8_CP,pref_8_CP,ptop_out_8_CP,my_ip1,my_ip2,stdout_unit_CP,dhm_CP,dht_CP) == VGD_ERROR)then
         print*,'In new_gen, problem with c_new_gen'
         return
      endif
      status = VGD_OK;
   end function new_gen

   integer function new_build_vert(self,kind,version,nk,ip1,ip2, &
        ptop_8,pref_8,rcoef1,rcoef2,a_m_8,b_m_8,a_t_8,b_t_8, &
        ip1_m,ip1_t) result(status)
      ! Coordinate constructor - build vertical descriptor from arguments
      type(vgrid_descriptor) :: self                    !Vertical descriptor instance    
      integer, intent(in) :: kind,version               !Kind,version to create
      integer, intent(in) :: nk                         !Number of levels
      integer,target , optional, intent(in) :: ip1,ip2          !IP1,2 values for FST file record [0,0]
      real,target , optional, intent(in) :: rcoef1,rcoef2       !R-coefficient values for rectification
      real*8,target , optional, intent(in) :: ptop_8            !Top-level pressure (Pa)
      real*8,target , optional, intent(in) :: pref_8            !Reference-level pressure (Pa)
      real*8,target , optional, dimension(:) :: a_m_8,a_t_8     !A-coefficients for momentum(m),thermo(t) levels
      real*8,target , optional, dimension(:) :: b_m_8,b_t_8     !B-coefficients for momentum(m),thermo(t) levels
      integer,target , optional, dimension(:) :: ip1_m,ip1_t    !Level ID (IP1) for momentum(m),thermo(t) levels

      ! Assign optional argument to C_NULL_PTR    

      ! Local variables
      type(c_ptr) :: rcoef1_CP, rcoef2_CP, ptop_8_CP, pref_8_CP
      type(c_ptr) :: a_m_8_CP, b_m_8_CP, a_t_8_CP, b_t_8_CP, ip1_m_CP, ip1_t_CP
      integer l_ip1,l_ip2,nl_m, nl_t, tempo

      status = VGD_ERROR

      nl_m=nk
      nl_t=-1

      if(present(ip1))then
         l_ip1 = ip1
      else
         l_ip1 = -1
      endif
      if(present(ip2))then
         l_ip2 = ip2
      else
         l_ip2 = -1
      endif
      if(present(ptop_8))then
         ptop_8_CP = c_loc(ptop_8)
      else
         ptop_8_CP = C_NULL_PTR
      endif
      if(present(pref_8))then
         pref_8_CP = c_loc(pref_8)
      else
         pref_8_CP = C_NULL_PTR
      endif
      if(present(rcoef1))then
         rcoef1_CP = c_loc(rcoef1)
      else
         rcoef1_CP = C_NULL_PTR
      endif
      if(present(rcoef2))then
         rcoef2_CP = c_loc(rcoef2)
      else
         rcoef2_CP = C_NULL_PTR
      endif
      if(present(a_m_8))then
         a_m_8_CP = c_loc(a_m_8)
         nl_m = size(a_m_8)
      else
         a_m_8_CP = C_NULL_PTR
      endif
      if(present(b_m_8))then
         b_m_8_CP = c_loc(b_m_8)
      else
         b_m_8_CP = C_NULL_PTR
      endif
      if(present(a_t_8))then
         a_t_8_CP = c_loc(a_t_8)
         nl_t = size(a_t_8)
      else
         a_t_8_CP = C_NULL_PTR
      endif
      if(present(b_t_8))then
         b_t_8_CP = c_loc(b_t_8)
      else
         b_t_8_CP = C_NULL_PTR
      endif
      if(present(ip1_m))then
         ip1_m_CP = c_loc(ip1_m)
      else
         ip1_m_CP = C_NULL_PTR
      endif
      if(present(ip1_t))then
         ip1_t_CP = c_loc(ip1_t)
      else
         ip1_t_CP = C_NULL_PTR
      endif
      !if(c_new_build_vert(self%cptr,kind,version,nk,l_ip1,l_ip2, &
      !     ptop_8_CP, pref_8_CP, rcoef1_CP, rcoef2_CP, &
      !     a_m_8_CP, b_m_8_CP, a_t_8_CP, b_t_8_CP, ip1_m_CP, ip1_t_CP, nl_m, nl_t) == VGD_ERROR)then

      print*,'new_build_vert nk, nl_m, nl_t',nk, nl_m, nl_t

      tempo=c_new_build_vert(self%cptr,kind,version,nk,l_ip1,l_ip2, &
           ptop_8_CP, pref_8_CP, rcoef1_CP, rcoef2_CP, &
           a_m_8_CP, b_m_8_CP, a_t_8_CP, b_t_8_CP, ip1_m_CP, ip1_t_CP, nl_m, nl_t)
      if(tempo == VGD_ERROR)then
         
         print*,'In new_build_vert, problem with c_new_build_vert',tempo,VGD_ERROR
         return
      endif

      status = VGD_OK;

   end function new_build_vert

   integer function garbage_collection(self) result(status)
      ! Wrapper function to C c_vgd_free
      type(vgrid_descriptor) :: self
      call c_vgd_free(self%cptr)
      status = VGD_OK
   end function garbage_collection

   integer function putopt_logical(key,value) result(status)
      character(len=*), intent(in) :: key           !Descriptor key to retrieve
      logical, intent(in) :: value                    !Retrieved value
      
      ! Local variables
      
      ! Set error status
      status=VGD_ERROR
      
      select case(trim(key))
      case ('ALLOW_RESHAPE')
         ALLOW_RESHAPE=value
      case DEFAULT
         write(for_msg,*) 'invalid key in call to putopt_logical: ',trim(key)
         call msg(MSG_ERROR,VGD_PRFX//for_msg)
         return
      end select
      ! Set status and return
      status = VGD_OK
      return
   end function putopt_logical
   
   integer function print_desc(self,stdout,convip_L) result(istat)      
      ! Wrapper function to C c_print_desc
      type(vgrid_descriptor) :: self
      integer, target, intent(in), optional :: stdout     !Output unit to write to [6]
      logical, intent(in), optional :: convip_L

      ! Internal variables
      type(c_ptr) :: stdout_CP, convip_CP
      integer, target :: one

      one = 1;

      istat = VGD_ERROR
      if(.not.c_associated(self%cptr))then
         print*,'dans print_descript self%cptr not associated'
         return
      endif

      stdout_CP = C_NULL_PTR
      convip_CP = C_NULL_PTR
      if(present(stdout)) stdout_CP = c_loc(stdout)
      if(present(convip_L))then
         if(convip_L)convip_CP = c_loc(one)
      endif

      istat = c_print_desc(self%cptr,stdout_CP,convip_CP)
   end function print_desc

   integer function get_int(self,key,value,quiet) result(status)
       use utils, only: up
      ! Retrieve the value of the requested instance variable
      type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
      character(len=*), intent(in) :: key                 !Descriptor key to retrieve
      integer,target, intent(out) :: value                !Retrieved value
      logical, optional, intent(in) :: quiet              !Do not print massages
      
      ! Internal variables
      type(c_ptr) :: quiet_CP, value_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: one

      one = 1
      
      quiet_CP = C_NULL_PTR
      if (present(quiet))then
         if(quiet) quiet_CP = c_loc(one)
      endif

      value_CP = c_loc(value)
      my_key=up(key(1:KEY_LENGTH))
      status = c_get_int(self%cptr,my_key//C_NULL_CHAR, value_CP, quiet_CP)
      
   end function get_int
 
   integer function get_int_1d(self,key,value,quiet) result(status)
      use utils, only: get_allocate,up,get_error
      ! Retrieve the value of the requested instance variable
      type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
      character(len=*), intent(in) :: key                 !Descriptor key to retrieve
      integer, dimension(:), pointer :: value             !Retrieved value
      logical, optional, intent(in) :: quiet              !Do not print massages
      
      ! Internal variables
      integer :: nl_, istat, level_msg, error
      type(c_ptr) :: quiet_CP, value_CP
      logical :: my_quiet
      character(len=KEY_LENGTH) :: my_key
      integer, target :: one

      one = 1

      ! Set error status
      status = VGD_ERROR
      
      level_msg=MSG_ERROR
      if(.not. is_valid(self,'SELF')) then
         write(for_msg,*) 'vgrid structure is not valid in get_int_1d'
         call msg(MSG_ERROR,VGD_PRFX//for_msg)       
         return
      endif
      my_quiet=.false.
      quiet_CP = C_NULL_PTR
      if (present(quiet)) my_quiet = quiet
      if(my_quiet)then
         level_msg=MSG_QUIET
         quiet_CP = c_loc(one)
      endif
      
      my_key=up(key(1:KEY_LENGTH))

      ! Map key name to derived-type element
      select case (my_key)
      case ('VIPM','VIP1')
         if (is_valid(self,"ip1_m_valid")) then
            istat = get_int(self,'NL_M',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(VIPM in get_int_1d)')
            if (istat /= 0) return
            value_CP = c_loc(value(1))
            status = c_get_int_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,quiet_CP)
         else
            error = int(get_error(key))
            return
         endif
      case ('VIPT')
         if (is_valid(self,"ip1_t_valid_get")) then
            if (is_valid(self,"ip1_t_valid")) then
               istat = get_int(self,'NL_T',nl_)
               istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(VIPT in get_int_1d)')
               if (istat /= 0) return
               value_CP = c_loc(value(1))
               status = c_get_int_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,quiet_CP)
            else
               istat = get_int(self,'NL_M',nl_)
               istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(VIPT in get_int_1d)')               
               if (istat /= 0) return
               value_CP = c_loc(value(1))
               status = c_get_int_1d(self%cptr,"VIPM"//C_NULL_CHAR,value_CP,quiet_CP)
            endif
         else
            error = int(get_error(key))
            return
         endif
      case DEFAULT
         write(for_msg,*) 'invalid key '//trim(key)//' given to gd_get (int 1D)'
         call msg(level_msg,VGD_PRFX//for_msg)
         return
      end select
      
      ! Set status and return
      status = VGD_OK
      return
      
   end function get_int_1d
   
   integer function get_real(self,key,value,quiet) result(status)
      use utils, only: up
      ! Retrieve the value of the requested instance variable
      type(vgrid_descriptor), intent(in) :: self   !Vertical descriptor instance
      character(len=*), intent(in) :: key          !Descriptor key to retrieve
      real, intent(out) :: value                   !Retrieved value
      logical, optional, intent(in) :: quiet       !Do not print massages
      
      ! Internal variables
      type(c_ptr) :: quiet_CP, value_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: one

      one = 1

      value = VGD_MISSING      

      quiet_CP = C_NULL_PTR
      if (present(quiet))then
         if(quiet) quiet_CP = c_loc(one)
      endif

      value_CP = c_loc(value)
      my_key=up(key(1:KEY_LENGTH))
      status = c_get_real(self%cptr,my_key//C_NULL_CHAR,value_CP,quiet_CP)
      
      return
   end function get_real
  

   integer function get_real_1d(self,key,value,quiet) result(status)
      use utils, only: get_allocate,up,get_error
      ! Retrieve the value of the requested instance variable
      type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
      character(len=*), intent(in) :: key         !Descriptor key to retrieve
      real, dimension(:), pointer :: value        !Retrieved value
      logical, optional, intent(in) :: quiet      !Do not print massages

      ! Internal variables
      integer :: istat,error,level_msg,k,kind
      integer, dimension(:), pointer :: vipt
      logical :: my_quiet
      type(c_ptr) :: quiet_CP, value_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: one

      one = 1

      ! Set error status
      status = VGD_ERROR
      
      nullify(vipt)
      
      level_msg=MSG_ERROR
      if(.not. is_valid(self,'SELF')) then
         write(for_msg,*) 'vgrid structure is not valid in get_real_1d'
         call msg(MSG_ERROR,VGD_PRFX//for_msg)
         return
      endif
      my_quiet=.false.
      quiet_CP = C_NULL_PTR
      if (present(quiet)) my_quiet = quiet
      if(my_quiet)then
         level_msg=MSG_QUIET
         quiet_CP = c_loc(one)
      endif
      
      my_key=up(key(1:KEY_LENGTH))
      
      ! Map key name to derived-type element
      select case (my_key)
      case ('VCDM')
         if (is_valid(self, "ip1_m_valid")) then
            istat=vgd_get(self,key='VIPM - level ip1 list (m)',value=vipt)
            istat = get_allocate(key,value,size(vipt),ALLOW_RESHAPE,'(VCDM in get_real_1d)')
            if (istat /= 0) return
            call convip(k,value(1),kind,0,'',.false.)
            do k=1,size(value)
               call convip(vipt(k),value(k),kind,-1,'',.false.)
            enddo
            deallocate(vipt)
         else
            error = int(get_error(key))
            return
         endif
      case ('VCDT')
         if (is_valid(self, "ip1_t_valid_get")) then
            if (is_valid(self,"ip1_t_valid")) then
               istat=vgd_get(self,key='VIPT - level ip1 list (t)',value=vipt)
            else
               istat=vgd_get(self,key='VIPM - level ip1 list (m)',value=vipt)
            endif
            if (istat /= VGD_OK)then
               if(associated(vipt))deallocate(vipt)
               return
            endif
            istat = get_allocate(key,value,size(vipt),ALLOW_RESHAPE,'(VCDT in get_real_1d)')
            istat=vgd_get(self,key='KIND',value=kind)
            call convip(k,value(1),kind,0,'',.false.)
            do k=1,size(vipt)
               call convip(vipt(k),value(k),kind,-1,'',.false.)
            enddo
            deallocate(vipt)
         else
            error = int(get_error(key))
            return
         endif
      case ('VCRD')
         if (is_valid(self,"ip1_m_valid")) then
            write(for_msg,*) 'depricated key '//trim(key)//', use VCDM instead'
            call msg(level_msg,VGD_PRFX//for_msg)
            return
         else
            error = int(get_error(key))
            return
         endif
      case DEFAULT
         write(for_msg,*) 'invalid key '//trim(key)//' given to gd_get (real 1D)'
         call msg(level_msg,VGD_PRFX//for_msg)
         return
      end select
      
      ! Set status and return
      status = VGD_OK
      return
   end function get_real_1d
   
   integer function get_real8_1d(self,key,value,quiet) result(status)
      use utils, only: get_allocate,up,get_error
      ! Wrapper function to C c_get_real8_1d
      type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
      character(len=*), intent(in) :: key         !Descriptor key to retrieve
      real(kind=8), dimension(:), pointer :: value !Retrieved value
      logical, target, optional, intent(in) :: quiet      !Do not print massages
      
      ! Internal variables
      integer :: nl_, istat, level_msg, error
      type(c_ptr) :: quiet_CP, value_CP
      logical :: my_quiet
      character(len=KEY_LENGTH) :: my_key
      integer, target :: one

      one = 1

      status = VGD_ERROR

      level_msg=MSG_ERROR
      if(.not. is_valid(self,'SELF')) then
         write(for_msg,*) 'vgrid structure is not valid in get_real8_1d'
         call msg(MSG_ERROR,VGD_PRFX//for_msg)       
         return
      endif
      my_quiet=.false.
      quiet_CP = C_NULL_PTR
      if (present(quiet)) my_quiet = quiet
      if(my_quiet)then
         level_msg=MSG_QUIET
         quiet_CP = c_loc(one)
      endif

      my_key=up(key(1:KEY_LENGTH))

      select case (my_key)
      case ('CA_M','COFA')
         if (is_valid(self,"a_m_8_valid")) then
            istat = get_int(self,'NL_M',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(CA_M in get_real8_1d)')         
            if (istat /= 0) return
            value_CP = c_loc(value(1))
            status = c_get_real8_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,quiet_CP)
         else
            error = int(get_error(key))
            return
         endif
      case ('CB_M','COFB')
         if (is_valid(self,"b_m_8_valid")) then
            istat = get_int(self,'NL_M',nl_)
            istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(CB_M in get_real8_1d)')         
            if (istat /= 0) return
            value_CP = c_loc(value(1))
            status = c_get_real8_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,quiet_CP)
         else
            error = int(get_error(key))
            return
         endif
      case ('CA_T')
         if (is_valid(self,"a_t_8_valid_get")) then
            if (is_valid(self,"a_t_8_valid")) then
               istat = get_int(self,'NL_T',nl_)
               istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(CA_T in get_real8_1d)')         
               if (istat /= 0) return
               value_CP = c_loc(value(1))
               status = c_get_real8_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,quiet_CP)
            else
               istat = get_int(self,'NL_M',nl_)
               istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(CA_T in get_real8_1d)')         
               if (istat /= 0) return
               value_CP = c_loc(value(1))
               status = c_get_real8_1d(self%cptr,'CA_M'//C_NULL_CHAR,value_CP,quiet_CP)
            endif
         else
            error = int(get_error(key))
            return
         endif
      case ('CB_T')
         if (is_valid(self,"b_t_8_valid_get")) then
            if (is_valid(self,"b_t_8_valid")) then
               istat = get_int(self,'NL_T',nl_)
               istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(CB_T in get_real8_1d)')         
               if (istat /= 0) return
               value_CP = c_loc(value(1))
               status = c_get_real8_1d(self%cptr,my_key//C_NULL_CHAR,value_CP,quiet_CP)
            else
               istat = get_int(self,'NL_M',nl_)
               istat = get_allocate(key,value,nl_,ALLOW_RESHAPE,'(CB_T in get_real8_1d)')         
               if (istat /= 0) return
               value_CP = c_loc(value(1))
               status = c_get_real8_1d(self%cptr,"CB_M"//C_NULL_CHAR,value_CP,quiet_CP)
            endif
         else
            error = int(get_error(key))
            return
         endif
      case DEFAULT
         write(for_msg,*) 'invalid key '//trim(key)//' given to gd_get (real8 1D)'
         call msg(level_msg,VGD_PRFX//for_msg)
         return
      end select
      ! Set status and return
      status = VGD_OK
      return      
   end function get_real8_1d

   integer function get_real8_3d(self,key,value,quiet) result(status)
      use utils, only: get_allocate,up
      ! Retrieve the value of the requested instance variable
      type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
      character(len=*), intent(in) :: key         !Descriptor key to retrieve
      real(kind=8), dimension(:,:,:), pointer :: value !Retrieved value
      logical, optional, intent(in) :: quiet      !Do not print massages

      ! Internal variables
      integer :: istat,level_msg
      integer, target, dimension(3) :: tshape
      logical :: my_quiet
      type(c_ptr) :: quiet_CP, value_CP, tshape_CP
      character(len=KEY_LENGTH) :: my_key
      integer, target :: one

      one = 1

      ! Set error status
      status = VGD_ERROR
      
      level_msg=MSG_ERROR
      if(.not. is_valid(self,'SELF'))then
         write(for_msg,*) 'vgrid structure is not valid in get_real8_3d'
         call msg(MSG_ERROR,VGD_PRFX//for_msg)       
         return
      endif
      my_quiet=.false.
      quiet_CP = C_NULL_PTR
      if (present(quiet)) my_quiet = quiet
      if(my_quiet)then
         level_msg=MSG_QUIET
         quiet_CP = c_loc(one)
      endif
      
      my_key=up(key(1:KEY_LENGTH))
      
      ! Map key name to derived-type element
      select case (my_key)
      case ('VTBL')
         tshape_CP = c_loc(tshape)
         call c_table_shape(self%cptr, tshape_CP)
         istat = get_allocate(key,value,tshape,ALLOW_RESHAPE,'(VTBL) in get_real8_3d)')         
         if (istat /= 0) return
         value_CP = c_loc(value)
         status = c_get_real8_3d(self%cptr,"VTBL"//C_NULL_CHAR,value_CP,quiet_CP)
         
      case DEFAULT
         write(for_msg,*) 'invalid key '//trim(key)//' given to gd_get (real8 3D)'
         call msg(level_msg,VGD_PRFX//for_msg)
         return
      end select
      
      ! Set status and return
      status = VGD_OK
      return
   end function get_real8_3d
    
   logical function is_valid(self,element_valid_S) result(valid)
      ! Check for validity of the element
      type(vgrid_descriptor) :: self          !Vertical descriptor instance
      character(len=*) :: element_valid_S
      valid =  c_is_valid(self%cptr,element_valid_S//C_NULL_CHAR) == 1
      return
   end function is_valid
      
end module vGrid_Descriptors

