!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
module vdescript_5002

  implicit none
  private

  ! Define class variables
#include "vgrid.hf"

  ! Define and publicize interfaces
  public :: vgrid_genab_5002
  interface reallocate
     module procedure PRIV_reallocate4
     module procedure PRIV_reallocate8
     module procedure PRIV_reallocateI
  end interface

contains
   !
   !**s/r vgrid_genab_5002  - Generates GEM model vertical grid parameters A, B and hyb
   !                      for momentun and thermodymic levels
   !
   !     ----------------------------------------------------------
   !    |                                                          |
   !    |   Set A, B and Z for momentum and thermodynamic levels   |
   !    |                                                          |
   !    |   according to the formulae:                             |
   !    |                                                          |
   !    |                Z = Zsrf + log(hyb)                       |
   !    |                                                          |
   !    |                A = Z                                     |
   !    |                                                          |
   !    |                B = (Z - Ztop)/(Zsrf-Ztop)**R             |
   !    |                                                          |
   !    |                Z = A(Z) + B(Z) * Zsrf                    |
   !    |                                                          |
   !    |                R = Rmax-(Rmax-Rmin)*(Z-Ztop)/(Zsrf-Ztop) |
   !    |                                                          |
   !     ----------------------------------------------------------
   
   subroutine vgrid_genab_5002 (F_hybuser,F_rcoef,F_ptop_8,F_pref_8, &
        F_hybm,F_hybt,F_am_8,F_bm_8,F_at_8,F_bt_8,F_ip1_m,F_ip1_t,F_err,lastTatU_L)

    ! Modifs 
    ! Andre Plante June 2012 : force real*8 in compuation of log(F_hybuser(k)*1.d0) in
      
    implicit none
    !      
    ! Arguments
    integer, intent(out) :: F_err
    real, dimension(:), intent(in) :: F_hybuser           ! user specification for vertical layering hyb
    real, dimension(:), intent(in) :: F_rcoef             ! user specification for rcoef
    real*8 , intent(in) :: F_ptop_8, F_pref_8             ! user specification for lid and reference pressures

    real, dimension(:), pointer :: F_hybm, F_hybt         ! model hyb values
    real*8, dimension(:), pointer :: F_am_8, F_bm_8       ! model As and Bs on momentum levels
    real*8, dimension(:), pointer :: F_at_8, F_bt_8       ! model As and Bs on thermodynamic levels
    integer, dimension(:), pointer :: F_ip1_m,F_ip1_t     ! ip1 values for momentum and thermodynamic levels
    logical, optional :: lastTatU_L                       ! Put last thermodynamic level at last momentum level

    ! Local variables
    integer :: k, status, nk
    logical :: wronghyb
    real    :: rcoef
    real*8  :: pr1, ztop_8, zsrf_8, eta_8, zeta_8
    logical :: my_lastTatU_L
    !     __________________________________________________________________

    F_err = VGD_ERROR

    my_lastTatU_L=.false.
    if(present(lastTatU_L))my_lastTatU_L=lastTatU_L

    ! Set size of the problem and check for full inputs
    nk = size(F_hybuser)
    if (size(F_rcoef) /= 2) then
       write(for_msg,*) 'Size of F_rcoef should be 2 in vdescript_5002::vgrid_genab_5002()... is ',size(F_rcoef)
       call vgrid_msg(MSG_CRITICAL,for_msg)
       return
    endif

    ! Check and allocate as required
    status = reallocate(F_hybm,0,nk+1)
    if (status /= VGD_OK) return
    status = reallocate(F_hybt,0,nk+2)
    if (status /= VGD_OK) return
    status = reallocate(F_am_8,1,nk+1)
    if (status /= VGD_OK) return
    status = reallocate(F_bm_8,1,nk+1)
    if (status /= VGD_OK) return
    status = reallocate(F_at_8,1,nk+2)
    if (status /= VGD_OK) return
    status = reallocate(F_bt_8,1,nk+2)
    if (status /= VGD_OK) return
    status = reallocate(F_ip1_m,1,nk+1)
    if (status /= VGD_OK) return
    status = reallocate(F_ip1_t,1,nk+2)
    if (status /= VGD_OK) return

    if (  Nk.lt.1 )  then
       write(for_msg,9100)
       call vgrid_msg(MSG_CRITICAL,for_msg)
       return
    endif
    
    if (F_ptop_8.le.0.d0) then
       write(for_msg,9400)
       call vgrid_msg(MSG_CRITICAL,for_msg)
       return
    endif
    !     
    !     Checking vertical layering
    !
    F_hybm(0) = F_ptop_8 / F_pref_8
    F_hybt(0) = F_hybm(0)
    !
    !     Check range
    !
    if (F_hybuser(NK).ge.1..or.F_hybuser(1).le.F_hybm(0))then
       write(for_msg,9550) F_hybm(0)
       call vgrid_msg(MSG_CRITICAL,for_msg)
       return
    endif
    !     
    !     Check monotonicity
    !
    wronghyb = .false.
    do k=2, NK
       if (F_hybuser(k).le.F_hybuser(k-1)) wronghyb = .true.
    enddo
    
    if (wronghyb) then
       write(for_msg,9250)
       call vgrid_msg(MSG_CRITICAL,for_msg)
       write(for_msg,*)'MOMENTUM LEVELS'
       call vgrid_msg(MSG_CRITICAL,for_msg)
       do k=1, NK
          write(for_msg,*) F_hybuser(k),k
          call vgrid_msg(MSG_CRITICAL,for_msg)
       end do
       return            
    endif
    !
    ztop_8  = log(F_ptop_8)
    zsrf_8  = log(F_pref_8)
    !
    !     ------------------------------------------------------------
    !    |                                                            |
    !    |   Set A and B for momentum and thermodynamic levels        |
    !    |                                                            |
    !    |   according to the formulae:                               |
    !    |                                                            |
    !    |                Z = Zsrf + log(hyb)                         |
    !    |                                                            |
    !    |                B = (Z - Ztop)/(Zsrf-Ztop)**R               |
    !    |                                                            |
    !    |                A = Z                                       |
    !    |                                                            |
    !    |                R = Rmax-(Rmax-Rmin)*(Z - Ztop)/(Zsrf-Ztop) |
    !    |                                                            |
    !     ------------------------------------------------------------
    !
    !     Momentum levels
    !
    pr1 = 1.0d0/(zsrf_8 - ztop_8)
    do k = 1, Nk
       zeta_8  = zsrf_8+log(F_hybuser(k)*1.d0)
       eta_8  = (zeta_8- ztop_8)*pr1
       rcoef   = F_rcoef(2)-(F_rcoef(2)-F_rcoef(1))*eta_8
       F_bm_8(k) = eta_8 ** rcoef
       F_am_8(k) = zeta_8
    enddo
    
    !     Special momentum levels for vert int.
    F_am_8(Nk+1) = zsrf_8
    F_bm_8(Nk+1) = 1.d0 
    
    
    !     Thermodynamic levels
    
    do k = 2, Nk
       F_bt_8(k)    = 0.5d0*(F_bm_8(k)   +F_bm_8(k-1)) 
       F_at_8(k)    = 0.5d0*(F_am_8(k)   +F_am_8(k-1)) 
    enddo
    
    !     Special thermo levels for vert int.
    F_bt_8(1)     = 0.5d0*(F_bm_8(1) + 0.d0)
    F_bt_8(Nk+1)  = 0.5d0*(F_bm_8(Nk) + 1.d0)
    F_bt_8(Nk+2)  = 1.d0
    F_at_8(1)     = 0.5d0*(F_am_8( 1) + ztop_8)
    F_at_8(Nk+1)  = 0.5d0*(F_am_8(Nk) + zsrf_8)
    F_at_8(Nk+2)  = zsrf_8
    
    F_hybm(1:NK) = F_hybuser(1:NK)
    
    F_hybt(1) = sqrt(F_hybm(0)*F_hybm(1))
    do k = 2, NK
       F_hybt(k) = sqrt(F_hybm(k)*F_hybm(k-1))
    enddo
    F_hybt(NK+1) = sqrt(F_hybm(NK))
    
    F_hybt(NK+2) = 1.0
    F_hybm(NK+1) = 1.0
    
    if(my_lastTatU_L)then
       F_at_8(Nk+1) =  F_am_8(Nk)
       F_bt_8(Nk+1) =  F_bm_8(Nk)
       F_hybt(Nk+1) =  F_hybm(Nk)
    endif    

    F_err = VGD_OK
 
    ! Compute ip1 values
    do k=1,nk+1
       call convip(F_ip1_m(k),F_hybm(k),5,2,'',.false.)
       call convip(F_ip1_t(k),F_hybt(k),5,2,'',.false.)
    enddo
    call convip(F_ip1_t(nk+2),F_hybt(nk+2),5,2,'',.false.)
    
9100 format (/'Insufficient number of vertical levels in variable hyb'/)
9250 format (/' ===> WRONG SPECIFICATION OF HYB VERTICAL LEVELS:'/ &
         '      LEVELS MUST BE MONOTONICALLY INCREASING'/     &
         '      FROM HYB(1) ---- ERROR ----'//                &
         '      Current choice:')
9400 format (/,'Cstv_ptop_8 must be > 0',/)
9550 format (/,'hyb must be < 1.0 and > ',es10.4,/)
    !     __________________________________________________________________
    return
 end subroutine vgrid_genab_5002

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function PRIV_reallocate4(v,low,high) result(status)
    ! Allocate space for outputs
    real, dimension(:), pointer :: v            !vector to allocate
    integer, intent(in) :: low,high             !bounds for vector
    integer :: status                           !return status of function
    
    ! Internal variables
    integer :: check

    ! Deallocate and re-allocate with the correct size
    status = VGD_ERROR
    if (associated(v)) then
       deallocate(v,stat=check)
       if (check /= 0) then
          write(for_msg,*) 'in deallocate() from vdescript_5002::reallocate()'
          call vgrid_msg(MSG_CRITICAL,for_msg)
          return
       endif
    endif
    allocate(v(low:high),stat=check)
    if (check /= 0) then
       write(for_msg,*) 'in allocate() from vdescript_5002::reallocate()'
       call vgrid_msg(MSG_CRITICAL,for_msg)
       return
    endif
    status = VGD_OK
    return
  end function PRIV_reallocate4

  function PRIV_reallocate8(v,low,high) result(status)
    ! Allocate space for outputs
    real*8, dimension(:), pointer :: v          !vector to allocate
    integer, intent(in) :: low,high             !bounds for vector
    integer :: status                           !return status of function
    
    ! Internal variables
    integer :: check

    ! Deallocate and re-allocate with the correct size
    status = VGD_ERROR
    if (associated(v)) then
       deallocate(v,stat=check)
       if (check /= 0) then
          write(for_msg,*) 'in deallocate() from vgrid_genab_5002::reallocate()'
          call vgrid_msg(MSG_CRITICAL,for_msg)
          return
       endif
    endif
    allocate(v(low:high),stat=check)
    if (check /= 0) then
       write(for_msg,*) 'in allocate() from vgrid_genab_5002::reallocate()'
       call vgrid_msg(MSG_CRITICAL,for_msg)
       return
    endif
    status = VGD_OK
    return
  end function PRIV_reallocate8

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function PRIV_reallocateI(v,low,high) result(status)
    ! Allocate space for outputs
    integer, dimension(:), pointer :: v         !vector to allocate
    integer, intent(in) :: low,high             !bounds for vector
    integer :: status                           !return status of function
    
    ! Internal variables
    integer :: check

    ! Deallocate and re-allocate with the correct size
    status = VGD_ERROR
    if (associated(v)) then
       deallocate(v,stat=check)
       if (check /= 0) then
          write(for_msg,*) 'in deallocate() from vdescript_5002::reallocate()'
          call vgrid_msg(MSG_CRITICAL,for_msg)
          return
       endif
    endif
    allocate(v(low:high),stat=check)
    if (check /= 0) then
       write(for_msg,*) 'in allocate() from vdescript_5002::reallocate()'
       call vgrid_msg(MSG_CRITICAL,for_msg)
       return
    endif
    status = VGD_OK
    return
  end function PRIV_reallocateI

end module vdescript_5002

