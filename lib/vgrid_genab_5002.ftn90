!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
module vdescript_5002

  implicit none
  private

  ! Define class variables
#include "vgrid.hf"

  ! Define and publicize interfaces
  public :: vgrid_genab_5002
  interface reallocate
     module procedure PRIV_reallocate4
     module procedure PRIV_reallocate8
     module procedure PRIV_reallocateI
  end interface

contains
   !
   !**s/r vgrid_genab_5002  - Generates GEM model vertical grid parameters A, B and hyb
   !                      for momentun and thermodymic levels
   !
   !     ----------------------------------------------------------
   !    |                                                          |
   !    |   Set A, B and Z for momentum and thermodynamic levels   |
   !    |                                                          |
   !    |   according to the formulae:                             |
   !    |                                                          |
   !    |                Z = Zsrf + log(hyb)                       |
   !    |                                                          |
   !    |                A = Z                                     |
   !    |                                                          |
   !    |                Lambda = (Z - Zu)/(Zsrf-Zu)               |
   !    |                                                          |
   !    |                R = Rmax-(Rmax-Rmin)*Lambda               |
   !    |                                                          |
   !    |                B = Lambda**R                             |
   !    |                                                          |
   !     ----------------------------------------------------------
   
   subroutine vgrid_genab_5002 (F_version,F_hybuser,F_rcoef,F_ptop_8,F_pref_8, &
        F_am_8,F_bm_8,F_at_8,F_bt_8,F_ip1_m,F_ip1_t,F_err,lastTatU_L,notop_L,ptop_out_8, &
        dhm,dht)
      
    ! Modifs 
    ! Andre Plante June 2012 : force real*8 in compuation of log(F_hybuser(k)*1.d0) in
      
    use utils, only: comp_diag_a

    implicit none
    !      
    ! Arguments
    integer, intent(out) :: F_err
    integer, intent(in) :: F_version                      ! vgrid version (2,3,4)
    real, dimension(:), intent(in) :: F_hybuser           ! user specification for vertical layering hyb
    real, dimension(:), intent(in) :: F_rcoef             ! user specification for rcoef
    real*8 , intent(in) :: F_ptop_8                       ! user specification for top pressure
    real*8 , optional, intent(out):: ptop_out_8            ! computed ptop if F_ptop_8 < 0
    real*8 , intent(in) :: F_pref_8                       ! user specification for reference pressure

    real*8, dimension(:), pointer :: F_am_8, F_bm_8       ! model As and Bs on momentum levels
    real*8, dimension(:), pointer :: F_at_8, F_bt_8       ! model As and Bs on thermodynamic levels
    integer, dimension(:), pointer :: F_ip1_m,F_ip1_t     ! ip1 values for momentum and thermodynamic levels
    logical, optional, intent(in) :: lastTatU_L           ! Put last thermodynamic level at last momentum level
    logical, optional, intent(in) :: notop_L              ! Do put the top thermodynamic level in output vector
    real, optional, intent(in) :: dhm, dht                ! Diag levels Height (m) for Momentum/Thermo levels

    ! Local variables
    integer :: k, status, nk, k_plus_top, k_plus_diag
    logical :: wronghyb
    real    :: rcoef
    real*8  :: pr1, ztop_8, zsrf_8, lamba_8,zeta_8, zetau_8,zeta2_8, l_ptop_8
    logical :: my_lastTatU_L, my_notop_L
    real, dimension(:), pointer :: hybm, hybt             ! model hyb values
    real*8, dimension(:), pointer :: at_8, bt_8
    integer, dimension(:), pointer :: ip1_t
    character(len=100) :: func_name
    real, parameter :: RGASD       =    0.287050000000E+03
    real, parameter :: GRAV        =    0.980616000000E+01
    real, parameter :: TCDK        =    0.273150000000E+03
    !     __________________________________________________________________

    func_name='vgrid_genab_5002'

    F_err = VGD_ERROR
    
    nullify(hybm,hybt,at_8,bt_8,ip1_t)

    if(F_version.lt.2.or.F_version.gt.5)then
       write(for_msg,*) 'In '//trim(func_name)//' : wrong version ->',F_version
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       return
    endif
    if(F_ptop_8.lt.0.and.F_version.lt.4)then
       write(for_msg,*)'In '//trim(func_name)//' F_ptop_8 must by > 0.0 got ',F_ptop_8
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       return
    endif
    if(.not.present(dhm).and.F_version.eq.5)then
       write(for_msg,*)'In '//trim(func_name)//' dhm must be present'
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       return
    endif
    if(.not.present(dht).and.F_version.eq.5)then
       write(for_msg,*)'In '//trim(func_name)//' dht must be present'
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       return
    endif

    k_plus_diag=0
    if(present(dhm))k_plus_diag=1
    
    my_lastTatU_L=.false.
    if(present(lastTatU_L))my_lastTatU_L=lastTatU_L
    my_notop_L=.false.
    if(present(notop_L))my_notop_L=notop_L
    k_plus_top=1
    if(my_notop_L)k_plus_top=0

    ! Set size of the problem and check for full inputs
    nk = size(F_hybuser)
    if (size(F_rcoef) /= 2) then
       write(for_msg,*) 'In '//trim(func_name)//' Size of F_rcoef should be 2, it is ',size(F_rcoef)
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       return
    endif

    ! Check and allocate as required
    status = reallocate(F_am_8,1,nk+1+k_plus_diag)
    if (status /= VGD_OK) return
    status = reallocate(F_bm_8,1,nk+1+k_plus_diag)
    if (status /= VGD_OK) return
    status = reallocate(F_at_8,1,nk+1+k_plus_diag+k_plus_top)
    if (status /= VGD_OK) return
    status = reallocate(F_bt_8,1,nk+1+k_plus_diag+k_plus_top)
    if (status /= VGD_OK) return
    status = reallocate(F_ip1_m,1,nk+1+k_plus_diag)
    if (status /= VGD_OK) return
    status = reallocate(F_ip1_t,1,nk+1+k_plus_diag+k_plus_top)
    if (status /= VGD_OK) return

    ! Allocate working thermo arrays
    status = reallocate(hybm,0,nk+1)
    if (status /= VGD_OK) return
    status = reallocate(hybt,0,nk+2+k_plus_diag)
    if (status /= VGD_OK) return
    status = reallocate(at_8,1,nk+2+k_plus_diag)
    if (status /= VGD_OK) return
    status = reallocate(bt_8,1,nk+2+k_plus_diag)
    if (status /= VGD_OK) return
    status = reallocate(ip1_t,1,nk+2+k_plus_diag)
    if (status /= VGD_OK) return

    zsrf_8  = log(F_pref_8)
    if ( nint(F_ptop_8).eq.-2.or.&
         nint(F_ptop_8).eq.-1) then
       ! Auto compute ptop and make B(1) = 0
       zetau_8 = zsrf_8+log(F_hybuser(1)*1.d0)
       zeta2_8 = zsrf_8+log(F_hybuser(2)*1.d0)
       ztop_8=0.5d0*(3.d0*zetau_8-zeta2_8)
       l_ptop_8=exp(ztop_8)
       if(nint(F_ptop_8).eq.-1) then
          ! Compute B(1) from ztop, B(1) != 0
          zetau_8 = ztop_8
       endif
    else if (F_ptop_8.le.0.d0)then
       write(for_msg,*)'In '//trim(func_name)//' F_ptop_8 must be > 0, got ',F_ptop_8
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       return
    else
       ! Compute B(1) from user's ztop
       l_ptop_8=F_ptop_8
       ztop_8  = log(F_ptop_8)
       zetau_8 = ztop_8
    endif
    !     
    !     Checking vertical layering
    !
    hybm(0) = l_ptop_8 / F_pref_8
    !
    !     Check range
    !
    if (F_hybuser(NK).ge.1..or.F_hybuser(1).le.hybm(0))then
       write(for_msg,'("hyb must be < 1.0 and > ",es15.4)') hybm(0)
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       return
    endif
    !     
    !     Check monotonicity
    !
    wronghyb = .false.
    do k=2, NK
       if (F_hybuser(k).le.F_hybuser(k-1)) wronghyb = .true.
    enddo
    
    if (wronghyb) then
       write(for_msg,*)'WRONG SPECIFICATION OF HYB VERTICAL LEVELS'
       write(for_msg,*)'LEVELS MUST BE MONOTONICALLY INCREASING'
       write(for_msg,*)'      FROM HYB(1) ---- ERROR ----'
       write(for_msg,*)'      Current choice:'
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       write(for_msg,*)'MOMENTUM LEVELS'
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       do k=1, NK
          write(for_msg,*) F_hybuser(k),k
          call msg(MSG_ERROR,VGD_PRFX//for_msg)
       end do
       return            
    endif
    !
    !     Momentum levels
    !
    pr1 = 1.0d0/(zsrf_8 - zetau_8)
    do k = 1, Nk
       zeta_8  = zsrf_8+log(F_hybuser(k)*1.d0)
       lamba_8  = (zeta_8- zetau_8)*pr1
       rcoef   = F_rcoef(2)-(F_rcoef(2)-F_rcoef(1))*lamba_8
       F_bm_8(k) = lamba_8 ** rcoef
       F_am_8(k) = zeta_8
    enddo
    
    F_am_8(Nk+1) = zsrf_8
    F_bm_8(Nk+1) = 1.d0 
    if(F_version.eq.5)then
       ! Integrating the hydrostatic eq with T=0C
       ! ln[p(z=dhm)] = ln(ps) - g/(Rd*T)*dhm
       ! s = ln(ps) - ln(pref)
       ! ln[p(z=dhm)] = ln(pref) - g/(Rd*T)*dhm + s
       ! => B=1, A = ln(pref) - g/(Rd*T)*dhm
       ! We take T at 0C
       !F_am_8(Nk+2) = log(F_pref_8) - GRAV*dhm/(RGASD*TCDK)
       F_am_8(Nk+2) = comp_diag_a(F_pref_8,dhm)
       F_bm_8(Nk+2) = 1.d0 
    endif
    
    !     Thermodynamic levels
    
    do k = 2, Nk
       bt_8(k)    = 0.5d0*(F_bm_8(k)   +F_bm_8(k-1)) 
       at_8(k)    = 0.5d0*(F_am_8(k)   +F_am_8(k-1)) 
    enddo
    
    !     Special thermo levels for vert int.
    bt_8(1)     = 0.5d0*(F_bm_8(1) + 0.d0)
    bt_8(Nk+1)  = 0.5d0*(F_bm_8(Nk) + 1.d0)
    bt_8(Nk+2)  = 1.d0
    at_8(1)     = 0.5d0*(F_am_8( 1) + ztop_8)
    at_8(Nk+1)  = 0.5d0*(F_am_8(Nk) + zsrf_8)
    at_8(Nk+2)  = zsrf_8
    if(F_version.eq.5)then
       !at_8(Nk+3) = log(F_pref_8) - GRAV*dht/(RGASD*TCDK)
       at_8(Nk+3) = comp_diag_a(F_pref_8,dht)
       bt_8(Nk+3)  = 1.d0
    endif
    
    hybm(1:NK) = F_hybuser(1:NK)
    
    hybt(1) = sqrt(hybm(0)*hybm(1))
    do k = 2, NK
       hybt(k) = sqrt(hybm(k)*hybm(k-1))
    enddo
    hybt(NK+1) = sqrt(hybm(NK))
    
    hybt(NK+2) = 1.0
    hybm(NK+1) = 1.0
    
    if(my_lastTatU_L)then
       at_8(Nk+1) =  F_am_8(Nk)
       bt_8(Nk+1) =  F_bm_8(Nk)
       hybt(Nk+1)   =  hybm(Nk)
    endif    

    ! Compute ip1 values
    do k=1,nk+1
       call convip(F_ip1_m(k),hybm(k),5,2,'',.false.)
       call convip(ip1_t(k),hybt(k),5,2,'',.false.)
    enddo
    call convip(ip1_t(nk+2),hybt(nk+2),5,2,'',.false.)

    if(F_version.eq.5)then
       ! Encoding kind= 4       : M  [metres] (height with respect to ground level)
       call convip(F_ip1_m(nk+2),dhm,4,2,'',.false.)
       call convip(ip1_t(nk+3),dht,4,2,'',.false.)
    endif

    if(my_notop_L)then
       F_at_8=at_8(2:nk+2+k_plus_diag)
       F_bt_8=bt_8(2:nk+2+k_plus_diag)
       F_ip1_t=ip1_t(2:nk+2+k_plus_diag)
    else
       F_at_8=at_8
       F_bt_8=bt_8
       F_ip1_t=ip1_t
    endif

    if(present(ptop_out_8))ptop_out_8=l_ptop_8

    deallocate(hybm,hybt,at_8,bt_8,ip1_t)

    F_err = VGD_OK 
    !     __________________________________________________________________
    return
 end subroutine vgrid_genab_5002

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function PRIV_reallocate4(v,low,high) result(status)
    ! Allocate space for outputs
    real, dimension(:), pointer :: v            !vector to allocate
    integer, intent(in) :: low,high             !bounds for vector
    integer :: status                           !return status of function
    
    ! Internal variables
    integer :: check

    ! Deallocate and re-allocate with the correct size
    status = VGD_ERROR
    if (associated(v)) then
       deallocate(v,stat=check)
       if (check /= 0) then
          write(for_msg,*) 'in deallocate() from vdescript_5002::reallocate()'
          call msg(MSG_ERROR,VGD_PRFX//for_msg)
          return
       endif
    endif
    allocate(v(low:high),stat=check)
    if (check /= 0) then
       write(for_msg,*) 'in allocate() from vdescript_5002::reallocate()'
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       return
    endif
    status = VGD_OK
    return
  end function PRIV_reallocate4

  function PRIV_reallocate8(v,low,high) result(status)
    ! Allocate space for outputs
    real*8, dimension(:), pointer :: v          !vector to allocate
    integer, intent(in) :: low,high             !bounds for vector
    integer :: status                           !return status of function
    
    ! Internal variables
    integer :: check

    ! Deallocate and re-allocate with the correct size
    status = VGD_ERROR
    if (associated(v)) then
       deallocate(v,stat=check)
       if (check /= 0) then
          write(for_msg,*) 'in deallocate() from vgrid_genab_5002::reallocate()'
          call msg(MSG_ERROR,VGD_PRFX//for_msg)
          return
       endif
    endif
    allocate(v(low:high),stat=check)
    if (check /= 0) then
       write(for_msg,*) 'in allocate() from vgrid_genab_5002::reallocate()'
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       return
    endif
    status = VGD_OK
    return
  end function PRIV_reallocate8

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function PRIV_reallocateI(v,low,high) result(status)
    ! Allocate space for outputs
    integer, dimension(:), pointer :: v         !vector to allocate
    integer, intent(in) :: low,high             !bounds for vector
    integer :: status                           !return status of function
    
    ! Internal variables
    integer :: check

    ! Deallocate and re-allocate with the correct size
    status = VGD_ERROR
    if (associated(v)) then
       deallocate(v,stat=check)
       if (check /= 0) then
          write(for_msg,*) 'in deallocate() from vdescript_5002::reallocate()'
          call msg(MSG_ERROR,VGD_PRFX//for_msg)
          return
       endif
    endif
    allocate(v(low:high),stat=check)
    if (check /= 0) then
       write(for_msg,*) 'in allocate() from vdescript_5002::reallocate()'
       call msg(MSG_ERROR,VGD_PRFX//for_msg)
       return
    endif
    status = VGD_OK
    return
  end function PRIV_reallocateI

end module vdescript_5002

