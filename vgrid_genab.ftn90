!-------------------------------------- LICENCE BEGIN ------------------------------------
!Environment Canada - Atmospheric Science and Technology License/Disclaimer, 
!                     version 3; Last Modified: May 7, 2008.
!This is free but copyrighted software; you can use/redistribute/modify it under the terms 
!of the Environment Canada - Atmospheric Science and Technology License/Disclaimer 
!version 3 or (at your option) any later version that should be found at: 
!http://collaboration.cmc.ec.gc.ca/science/rpn.comm/license.html 
!
!This software is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; 
!without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. 
!See the above mentioned License/Disclaimer for more details.
!You should have received a copy of the License/Disclaimer along with this software; 
!if not, you can write to: EC-RPN COMM Group, 2121 TransCanada, suite 500, Dorval (Quebec), 
!CANADA, H9P 1J3; or send e-mail to service.rpn@ec.gc.ca
!-------------------------------------- LICENCE END --------------------------------------
module vdescript

  implicit none
  private

  ! Define class variables
  integer, parameter, public :: VDESC_ERROR=-1
  integer, parameter, public :: VDESC_OK=0
  integer, private :: stdout

  ! Define and publicize interfaces
  public vgrid_genab2
  interface reallocate
     module procedure PRIV_reallocate4
     module procedure PRIV_reallocate8
     module procedure PRIV_reallocateI
  end interface

contains
!
!**s/r vgrid_genab2  - Generates GEM model vertical grid parameters A, B and hyb
!                      for momentun and thermodymic levels
!
!     ----------------------------------------------------------
!    |                                                          |
!    |   Set A, B and Z for momentum and thermodynamic levels   |
!    |                                                          |
!    |   according to the formulae:                             |
!    |                                                          |
!    |                Z = Zsrf + log(hyb)                       |
!    |                                                          |
!    |                A = Z                                     |
!    |                                                          |
!    |                B = (Z - Ztop)/(Zsrf-Ztop)**R             |
!    |                                                          |
!    |                Z = A(Z) + B(Z) * Zsrf                    |
!    |                                                          |
!    |                R = Rmax-(Rmax-Rmin)*(Z-Ztop)/(Zsrf-Ztop) |
!    |                                                          |
!    |   Ver_code=6 is assigned to this formula                 |
!     ----------------------------------------------------------

  subroutine vgrid_genab2 (F_code,F_unout,F_hybuser,F_rcoef,F_ptop_8,F_pref_8, &
       F_hybm,F_hybt,F_am_8,F_bm_8,F_at_8,F_bt_8,F_ip1_m,F_ip1_t,F_err)

    implicit none
    !      
    ! Arguments
    integer, intent(in) :: F_code                         ! code specification (only code=6 supported for now)
    integer, intent(in) :: F_unout                        ! stdout fortran unit for messaging
    real, dimension(:), intent(in) :: F_hybuser           ! user specification for vertical layering hyb
    real, dimension(:), intent(in) :: F_rcoef             ! user specification for rcoef
    real*8 , intent(in) :: F_ptop_8, F_pref_8             ! user specification for lid and reference pressures

    integer, intent(out):: F_err                          ! error exit code
    real, dimension(:), pointer :: F_hybm, F_hybt         ! model hyb values
    real*8, dimension(:), pointer :: F_am_8, F_bm_8       ! model As and Bs on momentum levels
    real*8, dimension(:), pointer :: F_at_8, F_bt_8       ! model As and Bs on thermodynamic levels
    integer, dimension(:), pointer :: F_ip1_m,F_ip1_t     ! ip1 values for momentum and thermodynamic levels

    ! Local variables
    integer :: k, status, nk
    logical :: wronghyb
    real    :: rcoef
    real*8  :: pr1, ztop_8, zsrf_8, eta_8, zeta_8
    !     __________________________________________________________________

    F_err = VDESC_ERROR
    stdout = F_unout

    ! Set size of the problem and check for full inputs
    nk = size(F_hybuser)
    if (size(F_rcoef) /= 2) then
       write(stdout,*) 'Size of F_rcoef should be 2 in vdescript::vgrid_genab2()... is ',size(F_rcoef)
       return
    endif

    ! Check and allocate as required
    status = reallocate(F_hybm,0,nk+1)
    if (status /= VDESC_OK) return
    status = reallocate(F_hybt,0,nk+2)
    if (status /= VDESC_OK) return
    status = reallocate(F_am_8,1,nk+1)
    if (status /= VDESC_OK) return
    status = reallocate(F_bm_8,1,nk+1)
    if (status /= VDESC_OK) return
    status = reallocate(F_at_8,1,nk+2)
    if (status /= VDESC_OK) return
    status = reallocate(F_bt_8,1,nk+2)
    if (status /= VDESC_OK) return
    status = reallocate(F_ip1_m,1,nk+1)
    if (status /= VDESC_OK) return
    status = reallocate(F_ip1_t,1,nk+2)
    if (status /= VDESC_OK) return

    code: if (F_code.eq.6) then

       if (  Nk.lt.1 )  then
          if (stdout.ge.0) write (stdout,9100)
          return
       endif

       if (F_ptop_8.le.0.d0) then
          if (stdout.ge.0) write(stdout,9400)
          return
       endif
       !     
       !     Checking vertical layering
       !
       F_hybm(0) = F_ptop_8 / F_pref_8
       F_hybt(0) = F_hybm(0)
       !
       !     Check range
       !
       if (F_hybuser(NK).ge.1..or.F_hybuser(1).le.F_hybm(0))then
          if (stdout.ge.0) write(stdout,9550) F_hybm(0)
          return
       endif
       !     
       !     Check monotonicity
       !
       wronghyb = .false.
       do k=2, NK
          if (F_hybuser(k).le.F_hybuser(k-1)) wronghyb = .true.
       enddo

       if (wronghyb) then
          if (stdout.ge.0) then
             write(stdout,9250)
             write(stdout,*)'MOMENTUM LEVELS'
             do k=1, NK
                write (stdout,*) F_hybuser(k),k
             end do
          endif
          return            
       endif
       !
       ztop_8  = log(F_ptop_8)
       zsrf_8  = log(F_pref_8)
       !
       !     ------------------------------------------------------------
       !    |                                                            |
       !    |   Set A and B for momentum and thermodynamic levels        |
       !    |                                                            |
       !    |   according to the formulae:                               |
       !    |                                                            |
       !    |                Z = Zsrf + log(hyb)                         |
       !    |                                                            |
       !    |                B = (Z - Ztop)/(Zsrf-Ztop)**R               |
       !    |                                                            |
       !    |                A = Z                                       |
       !    |                                                            |
       !    |                R = Rmax-(Rmax-Rmin)*(Z - Ztop)/(Zsrf-Ztop) |
       !    |                                                            |
       !     ------------------------------------------------------------
       !
       !     Momentum levels
       !
       pr1 = 1.0d0/(zsrf_8 - ztop_8)
       do k = 1, Nk
          zeta_8  = zsrf_8+log(F_hybuser(k))
          eta_8  = (zeta_8- ztop_8)*pr1
          rcoef   = F_rcoef(2)-(F_rcoef(2)-F_rcoef(1))*eta_8
          F_bm_8(k) = eta_8 ** rcoef
          F_am_8(k) = zeta_8
       enddo

       !     Special momentum levels for vert int.
       F_am_8(Nk+1) = zsrf_8
       F_bm_8(Nk+1) = 1.d0 


       !     Thermodynamic levels

       do k = 2, Nk
          F_bt_8(k)    = 0.5d0*(F_bm_8(k)   +F_bm_8(k-1)) 
          F_at_8(k)    = 0.5d0*(F_am_8(k)   +F_am_8(k-1)) 
       enddo

       !     Special thermo levels for vert int.
       F_bt_8(1)     = 0.5d0*(F_bm_8(1) + 0.d0)
       F_bt_8(Nk+1)  = 0.5d0*(F_bm_8(Nk) + 1.d0)
       F_bt_8(Nk+2)  = 1.d0
       F_at_8(1)     = 0.5d0*(F_am_8( 1) + ztop_8)
       F_at_8(Nk+1)  = 0.5d0*(F_am_8(Nk) + zsrf_8)
       F_at_8(Nk+2)  = zsrf_8

       F_hybm(1:NK) = F_hybuser(1:NK)

       F_hybt(1) = sqrt(F_hybm(0)*F_hybm(1))
       do k = 2, NK
          F_hybt(k) = sqrt(F_hybm(k)*F_hybm(k-1))
       enddo
       F_hybt(NK+1) = sqrt(F_hybm(NK))

       F_hybt(NK+2) = 1.0
       F_hybm(NK+1) = 1.0

       F_err = VDESC_OK

    else
       if (stdout.ge.0) write (stdout,4001) F_code
    endif code

    ! Compute ip1 values
    do k=1,nk+1
       call convip(F_ip1_m(k),F_hybm(k),5,2,'',.false.)
       call convip(F_ip1_t(k),F_hybt(k),5,2,'',.false.)
    enddo
    call convip(F_ip1_t(nk+2),F_hybt(nk+2),5,2,'',.false.)

4001 format (/'ERROR: Unrecognized F_code= ',i/)
9100 format (/'ERROR: Insufficient number of vertical levels in variable hyb'/)
9250 format (/' ===> WRONG SPECIFICATION OF HYB VERTICAL LEVELS:'/ &
         '      LEVELS MUST BE MONOTONICALLY INCREASING'/     &
         '      FROM HYB(1) ---- ERROR ----'//                &
         '      Current choice:')
9400 format (/,'ERROR: Cstv_ptop_8 must be > 0',/)
9550 format (/,'ERROR: hyb must be < 1.0 and > ',es10.4,/)
    !     __________________________________________________________________
    return
  end subroutine vgrid_genab2

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function PRIV_reallocate4(v,low,high) result(status)
    ! Allocate space for outputs
    real, dimension(:), pointer :: v            !vector to allocate
    integer, intent(in) :: low,high             !bounds for vector
    integer :: status                           !return status of function
    
    ! Internal variables
    integer :: check

    ! Deallocate and re-allocate with the correct size
    status = VDESC_ERROR
    if (associated(v)) then
       deallocate(v,stat=check)
       if (check /= 0) then
          write(stdout,*) 'Error in deallocate() from vdescript::reallocate()'
          return
       endif
    endif
    allocate(v(low:high),stat=check)
    if (check /= 0) then
       write(stdout,*) 'Error in allocate() from vdescript::reallocate()'
       return
    endif
    status = VDESC_OK
    return
  end function PRIV_reallocate4

  function PRIV_reallocate8(v,low,high) result(status)
    ! Allocate space for outputs
    real*8, dimension(:), pointer :: v          !vector to allocate
    integer, intent(in) :: low,high             !bounds for vector
    integer :: status                           !return status of function
    
    ! Internal variables
    integer :: check

    ! Deallocate and re-allocate with the correct size
    status = VDESC_ERROR
    if (associated(v)) then
       deallocate(v,stat=check)
       if (check /= 0) then
          write(stdout,*) 'Error in deallocate() from vgrid_genab2::reallocate()'
          return
       endif
    endif
    allocate(v(low:high),stat=check)
    if (check /= 0) then
       write(stdout,*) 'Error in allocate() from vgrid_genab2::reallocate()'
       return
    endif
    status = VDESC_OK
    return
  end function PRIV_reallocate8

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

  function PRIV_reallocateI(v,low,high) result(status)
    ! Allocate space for outputs
    integer, dimension(:), pointer :: v         !vector to allocate
    integer, intent(in) :: low,high             !bounds for vector
    integer :: status                           !return status of function
    
    ! Internal variables
    integer :: check

    ! Deallocate and re-allocate with the correct size
    status = VDESC_ERROR
    if (associated(v)) then
       deallocate(v,stat=check)
       if (check /= 0) then
          write(stdout,*) 'Error in deallocate() from vdescript::reallocate()'
          return
       endif
    endif
    allocate(v(low:high),stat=check)
    if (check /= 0) then
       write(stdout,*) 'Error in allocate() from vdescript::reallocate()'
       return
    endif
    status = VDESC_OK
    return
  end function PRIV_reallocateI

end module vdescript

