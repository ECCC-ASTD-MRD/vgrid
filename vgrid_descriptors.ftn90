module vGrid_Descriptors

  implicit none
  private

  ! Public methods
  public :: vgrid_descriptor                    !vertical grid descriptor structure
  public :: vgd_new                             !class constructor
  public :: vgd_get                             !get instance variable value
  public :: vgd_put                             !set instance variable value
  public :: vgd_print                           !dump plain-text contents of instance
  public :: vgd_write                           !write coordinates to a file
  public :: vgd_levels                          !compute physical level information

  ! Public class variables
  integer, parameter, public :: VGD_LEN_NAME=4  !maximum length of a variable name in the data file
  integer, parameter, public :: VGD_OK=0        !method return value on success
  integer, parameter, public :: VGD_ERROR=-1    !method return value on error
  real, parameter, public :: VGD_MISSING=-9999. !missing value returned for invalid entries

  ! Private class variables
  integer, parameter :: STDERR=0                !STDERR output unit
  integer, parameter :: LONG_STRING=1024        !number of characters in a long string
  character(len=VGD_LEN_NAME) :: ZNAME='!!'     !name of the vertical coodinate
  integer, parameter :: MAX_VKIND=100           !maximum number of 'kind' (used in error check)
  integer, parameter :: KEY_LENGTH=4            !length of key string considered for get/put operations
  integer, parameter :: MAX_DESC_REC=10000      !maximum number of descriptor records in a single file
  character(len=1), dimension(3), parameter :: MATCH_GRTYP=(/'X','Y','Z'/) !grid types with ip1,2 to ig1,2 mapping

  ! Validity table
  integer, dimension(3), parameter :: ptop_8_valid=(/1002,5001,5002/)
  integer, dimension(2), parameter :: pref_8_valid=(/5001,5002/)
  integer, dimension(2), parameter :: rcoef1_valid=(/5001,5002/)
  integer, dimension(1), parameter :: rcoef2_valid=(/5002/)
  integer, dimension(5), parameter :: a_m_8_valid=(/1001,1002,2001,5001,5002/)
  integer, dimension(5), parameter :: b_m_8_valid=(/1001,1002,2001,5001,5002/)
  integer, dimension(1), parameter :: a_t_8_valid=(/5002/)
  integer, dimension(1), parameter :: b_t_8_valid=(/5002/)
  integer, dimension(5), parameter :: ip1_m_valid=(/1001,1002,2001,5001,5002/)
  integer, dimension(1), parameter :: ip1_t_valid=(/5002/)
  integer, dimension(4), parameter :: ref_name_valid=(/1001,1002,5001,5002/)

  ! FST file record structure
  type FSTD
     private
     integer :: ip3,ig1,ig2,ig3,ig4,dateo,deet,npas,datyp,nbits
     character(len=1) :: grtyp
     character(len=2) :: typvar
     character(len=4) :: nomvar
     character(len=12) :: etiket
  end type FSTD
  type FSTD_ext
     private
     integer :: ig1,ig2,ig3,ig4,dateo,deet,npas,datyp,nbits,ni,nj,nk
     integer :: ip1,ip2,ip3,swa,lng,dltf,ubc,extra1,extra2,extra3,datev
     character(len=1) :: grtyp
     character(len=2) :: typvar
     character(len=4) :: nomvar
     character(len=12) :: etiket
  end type FSTD_ext

  ! Combined coordinate structure
  type vgrid_descriptor
     private
     integer :: ip1=0,ip2=0                             !ip1,2 values given to the 3D descriptor
     integer :: unit                                    !file unit associated with this 3D descriptor
     logical :: match_ipig                              !do ip/ig matching for records
     character(len=VGD_LEN_NAME) :: ref_name            !reference field name
     integer, dimension(:), pointer :: ip1_m=>null()    !ip1 values for momentum levels
     integer, dimension(:), pointer :: ip1_t=>null()    !ip1 values for thermodynamic levels
     real(kind=8), dimension(:), pointer :: a_m_8=>null()!A-coefficients for momentum levels
     real(kind=8), dimension(:), pointer :: b_m_8=>null()!B-coefficients for momentum levels
     real(kind=8), dimension(:), pointer :: a_t_8=>null()!A-coefficients for thermodynamic levels
     real(kind=8), dimension(:), pointer :: b_t_8=>null()!B-coefficients for thermodynamic levels
     real(kind=8), dimension(:,:,:), pointer :: table=>null()!complete grid descriptor record
     real*8 :: ptop_8,pref_8                            !Top level and reference pressures (Pa)
     real :: rcoef1,rcoef2                              !Rectification coefficients
     type(FSTD) :: rec                                  !FST file record structure for descriptor
     integer :: vcode,kind,version                      !Vertical coordinate codes
  end type vgrid_descriptor

  interface vgd_new
     module procedure new_read
     module procedure new_build_vert
     module procedure new_gen
  end interface

  interface vgd_get
     module procedure get_int
     module procedure get_int_1d
     module procedure get_real
     module procedure get_real_1d
     module procedure get_real8
     module procedure get_real8_1d
     module procedure get_real8_3d
     module procedure get_char
     module procedure get_logical
  end interface

  interface vgd_put
     module procedure put_int
     module procedure put_int_1d
     module procedure put_real_1d
     module procedure put_real8
     module procedure put_real8_1d
     module procedure put_real8_3d
     module procedure put_char
  end interface

  interface vgd_print
     module procedure print_desc
  end interface

  interface vgd_write
     module procedure write_desc
  end interface

  interface vgd_levels
     module procedure levels_toplevel
     module procedure levels_readref
     module procedure levels_withref
     module procedure levels_withref_prof
  end interface

  interface size_ok
     module procedure size_ok_i1d
     module procedure size_ok_r81d
     module procedure size_ok_r83d
  end interface

  interface set_vcode
     module procedure set_vcode_d
     module procedure set_vcode_i
  end interface

  interface get_allocate
     module procedure get_allocate_i1d
     module procedure get_allocate_r1d
     module procedure get_allocate_r81d
     module procedure get_allocate_r83d
  end interface

  interface flip_transfer
     module procedure flip_transfer_r8
     module procedure flip_transfer_char
  end interface

contains

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Class constructor

   integer function new_read(self,unit,format,ip1,ip2) result(status)
      ! Coordinate constructor - read from a file and initialize instance
      type(vgrid_descriptor), intent(out) :: self !Vertical descriptor instance
      integer, intent(in) :: unit                 !File unit to read descriptor information from
      character(len=*), optional, intent(in) :: format !File format ('fst' or 'bin')
      integer,optional :: ip1,ip2                 !ip1,2 values of the desired descriptors

      ! Internal variables
      integer :: istat,key,error,kind,version,count,i,myip1,myip2
      integer :: fstinf,fstinl,fstluk,fstprm,ni,nj,nk,swa,lng,ubc,dltf,extra1,extra2,extra3
      integer, dimension(MAX_DESC_REC) :: keyList
      type(FSTD_ext) :: var
      real*8, dimension(:,:,:), allocatable :: l_table
      character(len=100) :: myformat

      ! Set error status
      status = VGD_ERROR

      ! Set default values
      myformat='FST'
      if (present(format)) myformat = format
      myip1 = -1
      if (present(ip1)) myip1 = ip1
      myip2 = -1
      if (present(ip2)) myip2 = ip2

      ! Set instance variables
      self%unit = unit
      if (any((/myip1,myip2/) < 0)) then
         self%match_ipig = .false.
      else
         self%match_ipig = .true.
      endif

      ! Construct vertical descriptor
      self%rec%nomvar = ZNAME
      select case (trim(up(myformat)))

         ! RPN Standard file input
      case ('FST')
         key=fstinf(unit,ni,nj,nk,-1,' ',myip1,myip2,-1,' ',self%rec%nomvar)
         if(key < 0)then
            write(STDERR,'("WARNING: cannot find '//trim(self%rec%nomvar)//' with the following: ip1=",i10,",ip2=",i10)')myip1,myip2
            self%vcode = -1
            return
         endif
         allocate(self%table(ni,nj,nk),stat=istat)
         if (istat /= 0) then
            write(STDERR,*) 'ERROR: unable to allocate self%table'
            return
         endif
         istat=fstluk(self%table,key,ni,nj,nk)
         if(istat < 0)then
            write(STDERR,*) 'ERROR: problem with fstluk on '//trim(self%rec%nomvar)
            return
         endif
         ! Sorry, I have to use fstprm!
         istat=fstprm(key, self%rec%dateo, self%rec%deet, self%rec%npas, &
              ni, nj, nk, self%rec%nbits, self%rec%datyp, self%ip1, self%ip2, self%rec%ip3, &
              self%rec%typvar,self%rec%nomvar, self%rec%etiket, self%rec%grtyp,&
              self%rec%ig1, self%rec%ig2, self%rec%ig3, self%rec%ig4, &
              swa,lng,dltf,ubc,extra1,extra2,extra3)         

         ! Check for multiple (different) descriptors
         error = fstinl(unit,ni,nj,nk,-1,' ',myip1,myip2,-1,' ',self%rec%nomvar,keyList,count,size(keyList))
         if (error < 0) then
            write(STDERR,*) 'ERROR: problem retrieving '//trim(self%rec%nomvar)//' keys for ip1,ip2: ',myip1,myip2
            self%vcode = -1
            return
         endif
         if(count>1)then
            allocate(l_table(ni,nj,nk),stat=istat)
            if (istat /= 0) then
               write(STDERR,*) 'ERROR: unable to allocate l_table'
               return
            endif
            do i=2,count
               error=my_fstprm(keyList(i),var)
               if (error < 0) then
                  write(STDERR,*) 'ERROR: problem with my_fstprm in new_read'
                  self%vcode = -1
                  return
               endif
               if(var%ip1 /= self%ip1 .or. var%ip2 /= self%ip2 .or. &
                    var%ni  /= ni     .or. var%nj  /= nj     .or.  var%nk  /= nk )then
                  write(STDERR,*) 'ERROR: found different vertical descriptors after wildcard (-1) search'
                  self%vcode = -1
                  return
               endif
               istat=fstluk(l_table,keyList(i),ni,nj,nk)
               if(istat < 0)then
                  write(STDERR,*) 'ERROR: problem with fstluk on l_table i=',i
                  return
               endif
               if(any(l_table /= self%table))then
                  write(STDERR,*) 'ERROR: found different entries in vertical descriptors after wildcard (-1) search'
                  return
               endif
            enddo
            deallocate(l_table)
         endif

         ! Fortran binary file input (must already be in the correct position)
      case ('BIN')
         read(unit) ni,nj,nk
         allocate(self%table(ni,nj,nk),stat=istat)
         if (istat /= 0) then
            write(STDERR,*) 'ERROR: unable to allocate self%table'
            return
         endif
         read(unit) self%table
         self%rec%dateo = 0
         self%rec%deet = 0
         self%rec%npas = 0
         self%rec%nbits = 32
         self%rec%datyp = 1
         self%rec%ip3 = 0
         self%rec%typvar = 'X'
         self%rec%etiket = ''
         self%rec%grtyp = 'X'
         self%rec%ig1 = 0
         self%rec%ig2 = 0
         self%rec%ig3 = 0
         self%rec%ig4 = 0

         ! Warn user on invalid input format specification
      case DEFAULT
         write(STDERR,*) 'ERROR: invalid constructor format request ',trim(myformat)
         return
      end select

      ! Set internal vcode (if all above was successful)
      error = set_vcode(self)
      select case (self%vcode)
      case (1001)
         istat=decode_vert_1001(self)
         if(istat < 0)then
            write(STDERR,*) 'ERROR: problem with fstluk on '//trim(self%rec%nomvar)
            return
         endif
      case (1002)
         istat=decode_vert_1002(self)
         if(istat < 0)then
            write(STDERR,*) 'ERROR: problem with fstluk on '//trim(self%rec%nomvar)
            return
         endif
      case (2001)
         istat=decode_vert_2001(self)
      case (5001)
         istat=decode_vert_5001(self)
         if(istat < 0)then
            write(STDERR,*) 'ERROR: problem with fstluk on '//trim(self%rec%nomvar)
            return
         endif
      case (5002)
         istat=decode_vert_5002(self)
         if(istat < 0)then
            write(STDERR,*) 'ERROR: problem with fstluk on '//trim(self%rec%nomvar)
            return
         endif
      case DEFAULT
         istat = get_version_info(self,kind,version)
         write(STDERR,*) 'ERROR: invalid kind or version:',kind,version
         return
      end select

      ! Set status and return
      if (found_descriptor(self)) status = VGD_OK
      return
   end function new_read

   integer function new_build_vert(self,kind,version,nk,ip1,ip2, &
        ptop_8,pref_8,rcoef1,rcoef2,a_m_8,b_m_8,a_t_8,b_t_8, &
        ip1_m,ip1_t) result(status)
      ! Coordinate constructor - build vertical descriptor from arguments
      type(vgrid_descriptor), intent(out) :: self       !Vertical descriptor instance    
      integer, intent(in) :: kind,version               !Kind,version to create
      integer, intent(in) :: nk                         !Number of levels
      integer, optional, intent(in) :: ip1,ip2          !IP1,2 values for FST file record [0,0]
      real, optional, intent(in) :: rcoef1,rcoef2       !R-coefficient values for rectification
      real*8, optional, intent(in) :: ptop_8            !Top-level pressure (Pa)
      real*8, optional, intent(in) :: pref_8            !Reference-level pressure (Pa)
      real*8, optional, dimension(:) :: a_m_8,a_t_8     !A-coefficients for momentum(m),thermo(t) levels
      real*8, optional, dimension(:) :: b_m_8,b_t_8     !B-coefficients for momentum(m),thermo(t) levels
      integer, optional, dimension(:) :: ip1_m,ip1_t    !Level ID (IP1) for momentum(m),thermo(t) levels

      ! Local variables
      integer :: error,nn,ig1,ig2,ig3,ig4,k
      character(len=4) :: cvcode
      logical :: missingInput

      ! Set error status
      status = VGD_ERROR

      ! Initializations
      self%rec%nomvar = ZNAME
      self%kind=kind
      self%version=version
      self%rec%dateo=0
      self%rec%ip3=0
      if (present(ip1)) self%ip1 = ip1
      if (present(ip2)) self%ip2 = ip2
      self%unit = -1      
      self%match_ipig=.true.

      ! Check for required inputs
      error = set_vcode(self,kind,version)
      missingInput = .false.
      if(is_valid(self,ptop_8_valid)) then
         if(present(ptop_8))then
            self%ptop_8 = ptop_8
         else
            write(STDERR,*) 'ERROR: ptop_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,pref_8_valid)) then
         if(present(pref_8))then
            self%pref_8 = pref_8
         else
            write(STDERR,*) 'ERROR: pref_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,rcoef1_valid)) then
         if(present(rcoef1))then
            self%rcoef1 = rcoef1
         else
            write(STDERR,*) 'ERROR: rcoef1 is a required constructor entry'
            missingInput = .true.
         endif
      endif     
      if(is_valid(self,rcoef2_valid)) then
         if(present(rcoef2))then
            self%rcoef2 = rcoef2
         else
            write(STDERR,*) 'ERROR: rcoef2 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,a_m_8_valid)) then
         if(present(a_m_8))then
            if (associated(self%a_m_8)) deallocate(self%a_m_8)
            allocate(self%a_m_8(size(a_m_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating a_m_8 in new_build_vert'
               return
            endif
            self%a_m_8 = a_m_8
         else
            write(STDERR,*) 'ERROR: a_m_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,b_m_8_valid)) then
         if(present(b_m_8))then
            if (associated(self%b_m_8)) deallocate(self%b_m_8)
            allocate(self%b_m_8(size(b_m_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating b_m_8 in new_build_vert'
               return
            endif
            self%b_m_8 = b_m_8
         else
            write(STDERR,*) 'ERROR: b_m_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,a_t_8_valid)) then
         if(present(a_t_8))then
            if (associated(self%a_t_8)) deallocate(self%a_t_8)
            allocate(self%a_t_8(size(a_t_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating a_t_8 in new_build_vert'
               return
            endif
            self%a_t_8 = a_t_8
         else
            write(STDERR,*) 'ERROR: a_t_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,b_t_8_valid)) then
         if(present(b_t_8))then
            if (associated(self%b_t_8)) deallocate(self%b_t_8)
            allocate(self%b_t_8(size(b_t_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating b_t_8 in new_build_vert'
               return
            endif
            self%b_t_8 = b_t_8
         else
            write(STDERR,*) 'ERROR: b_t_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if(is_valid(self,ip1_m_valid)) then
         if(present(ip1_m))then
            if (associated(self%ip1_m)) deallocate(self%ip1_m)
            allocate(self%ip1_m(size(ip1_m)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating ip1_m in new_build_vert'
               return
            endif
            self%ip1_m = ip1_m
         else
            write(STDERR,*) 'ERROR: ip1_m is a required constructor entry'
            missingInput = .true.
         endif
      endif      
      if(is_valid(self,ip1_t_valid)) then
         if(present(ip1_t))then
            if (associated(self%ip1_t)) deallocate(self%ip1_t)
            allocate(self%ip1_t(size(ip1_t)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating ip1_t in new_build_vert'
               return
            endif
            self%ip1_t = ip1_t
         else
            write(STDERR,*) 'ERROR: ip1_t is a required constructor entry'
            missingInput = .true.
         endif
      endif      
      if (is_valid(self,a_m_8_valid)) then
         if(present(a_m_8))then
            if (associated(self%a_m_8)) deallocate(self%a_m_8)
            allocate(self%a_m_8(size(a_m_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating a_m_8 in new_build_vert'
               return
            endif
            self%a_m_8 = a_m_8
         else
            write(STDERR,*) 'ERROR: a_m_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if (is_valid(self,b_m_8_valid)) then
         if(present(b_m_8))then
            if (associated(self%b_m_8)) deallocate(self%b_m_8)
            allocate(self%b_m_8(size(b_m_8)),stat=error)
            if(error < 0)then
               write(STDERR,*) 'ERROR: problem allocating b_m_8 in new_build_vert'
               return
            endif
            self%b_m_8 = b_m_8
         else
            write(STDERR,*) 'ERROR: b_m_8 is a required constructor entry'
            missingInput = .true.
         endif
      endif
      if (missingInput) return

      ! Fill table with version-specific encoder
      select case (self%vcode)
      case (1001)
         error = encode_vert_1001(self,nk)
      case (1002)
         error = encode_vert_1002(self,nk)
      case (2001)
         error = encode_vert_2001(self)
      case (5001)
         error = encode_vert_5001(self,nk)
      case (5002)
         error = encode_vert_5002(self,nk)
      case DEFAULT
         write(STDERR,*) 'ERROR: unsupported kind and version : ',kind,version,' (vcode) ',self%vcode
         return
      end select
      if (error /= VGD_OK) then
         write(cvcode,'(i4)') self%vcode
         write(STDERR,*) 'ERROR: problem with encode_vert_'//trim(cvcode)
         return
      endif

      ! Set status and return
      status = VGD_OK
      return
   end function new_build_vert

   integer function new_gen(self,kind,version,hyb,rcoef1,rcoef2,ptop_8,pref_8,ip1,ip2,stdout_unit) result(status)
      use vdescript_1001
      use vdescript_1002_5001
      use vdescript_5002
      ! Coordinate constructor - build vertical descriptor from hybrid coordinate entries
      type(vgrid_descriptor), intent(out) :: self       !Vertical descriptor instance    
      integer, intent(in) :: kind,version               !Kind,version to create
      real, dimension(:), intent(in) :: hyb             !List of hybrid levels
      real, optional, intent(in) :: rcoef1,rcoef2       !R-coefficient values for rectification
      real*8, optional, intent(in) :: ptop_8            !Top-level pressure (Pa)
      real*8, optional, intent(in) :: pref_8            !Reference-level pressure (Pa)
      integer, optional, intent(in) :: ip1,ip2          !IP1,2 values for FST file record [0,0]
      integer, intent(in), optional :: stdout_unit      !Unit number for verbose output [STDERR]

      ! Internal variables
      integer :: myip1,myip2,mystdout_unit,error
      integer, dimension(:), pointer :: ip1_m,ip1_t
      real, dimension(:), pointer :: hybm,hybt
      real*8, dimension(:), pointer :: a_m_8,b_m_8,a_t_8,b_t_8
      logical :: gen_ok,errorInput=.false.

      ! Set error status
      status = VGD_ERROR

      ! Set default values
      myip1 = 0
      if (present(ip1)) myip1 = ip1
      myip2 = 0
      if (present(ip2)) myip2 = ip2
      mystdout_unit = STDERR
      if (present(stdout_unit)) mystdout_unit = stdout_unit

      error = VGD_ERROR
      ! Check for required inputs

      error = set_vcode(self,kind,version)
      errorInput = .false.
      if(is_valid(self,ptop_8_valid)) then
         if(.not.present(ptop_8))then
            write(STDERR,*) 'ERROR: ptop_8 is a required constructor entry'
            errorInput = .true.
         endif
      endif
      if(is_valid(self,pref_8_valid)) then
         if(.not.present(pref_8))then
            write(STDERR,*) 'ERROR: pref_8 is a required constructor entry'
            errorInput = .true.
         endif
      endif
      if(is_valid(self,rcoef1_valid)) then
         if(.not.present(rcoef1))then
            write(STDERR,*) 'ERROR: rcoef1 is a required constructor entry'
            errorInput = .true.
         endif
      endif
      if(is_valid(self,rcoef2_valid)) then
         if(.not.present(rcoef2))then
            write(STDERR,*) 'ERROR: rcoef2 is a required constructor entry'
            errorInput = .true.
         endif
      endif
      if(present(ptop_8).and.(.not.is_valid(self,ptop_8_valid)))then
         write(STDERR,*) 'ERROR: ptop_8 is not a required constructor entry'
         errorInput = .true.
      endif
      if(present(pref_8).and.(.not.is_valid(self,pref_8_valid)))then
         write(STDERR,*) 'ERROR: pref_8 is not a required constructor entry'
         errorInput = .true.
      endif
      if(present(rcoef1).and.(.not.is_valid(self,rcoef1_valid)))then
         write(STDERR,*) 'ERROR: rcoef1 is not a required constructor entry'
         errorInput = .true.
      endif
      if(present(rcoef2).and.(.not.is_valid(self,rcoef2_valid)))then
         write(STDERR,*) 'ERROR: rcoef2 is not a required constructor entry'
         errorInput = .true.
      endif
      if (errorInput) return

      ! Call appropriate support module to compute required values
      select case (self%vcode)
      case(1001)
         call vgrid_genab_1001(6,hyb,hybm,a_m_8,b_m_8,ip1_m,error)
         if (error /= VDESC_1001_OK)then
            return
         endif
         print*,b_m_8
         error = vgd_new(self,kind,version,size(hyb), &
              ip1=myip1,           &
              ip2=myip2,           &
              a_m_8=a_m_8,         &
              b_m_8=b_m_8,         &
              ip1_m=ip1_m)
         if (error /= VGD_OK) return        
      case (1002)
         call vgrid_genab_1002_5001(6,self%vcode,hyb,1.,ptop_8,80000.d0, &
              hybm,a_m_8,b_m_8,ip1_m,error)
         if (error /= VDESC_1002_5001_OK)then
            return
         endif
         error = vgd_new(self,kind,version,size(hyb), &
              ip1=myip1,           &
              ip2=myip2,           &
              ptop_8=ptop_8,       &
              a_m_8=a_m_8,         &
              b_m_8=b_m_8,         &
              ip1_m=ip1_m)
         if (error /= VGD_OK) return
      case (5001)
         call vgrid_genab_1002_5001(6,self%vcode,hyb,rcoef1,ptop_8,pref_8, &
              hybm,a_m_8,b_m_8,ip1_m,error)
         if (error /= VDESC_1002_5001_OK)then
            return
         endif
         error = vgd_new(self,kind,version,size(hyb), &
              ip1=myip1,           &
              ip2=myip2,           &
              ptop_8=ptop_8,       &
              pref_8=pref_8,       &
              rcoef1=rcoef1,       &
              a_m_8=a_m_8,         &
              b_m_8=b_m_8,         &
              ip1_m=ip1_m)
         if (error /= VGD_OK) return
      case (5002)
         call vgrid_genab_5002(mystdout_unit,hyb,(/rcoef1,rcoef2/),ptop_8,pref_8, &
              hybm,hybt,a_m_8,b_m_8,a_t_8,b_t_8,ip1_m,ip1_t,error)
         if (error /= VDESC_5002_OK) return
         error = vgd_new(self,kind,version,size(hyb), &
              ip1=myip1,           &
              ip2=myip2,           &
              ptop_8=ptop_8,       &
              pref_8=pref_8,       &
              rcoef1=rcoef1,       &
              rcoef2=rcoef2,       &
              a_m_8=a_m_8,         &
              b_m_8=b_m_8,         &
              a_t_8=a_t_8,         &
              b_t_8=b_t_8,         &
              ip1_m=ip1_m,         &
              ip1_t=ip1_t)
         if (error /= VGD_OK) return
      case DEFAULT
         write(STDERR,*)'ERROR: unsuported IP1 kind = ',kind,', AND/OR version = ',version
         return
      end select
      
      ! Set status and return
      status = VGD_OK
      return
   end function new_gen

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Get methods

  integer function get_logical(self,key,value) result(status)
    ! Retrieve the value of the requested instance variable
    type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
    character(len=*), intent(in) :: key                 !Descriptor key to retrieve
    logical, intent(out) :: value                       !Retrieved value
    
    ! Local variables
    integer :: error

    ! Set error status
    status = VGD_ERROR

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('LOGP')
       select case (self%vcode)
       case (1001,1002,5001)
          value=.false.
       case (5002)
          value=.true.
       case DEFAULT
          write(STDERR,*) 'ERROR: unsupported vcode for LOGP: ',self%vcode
          return
       end select
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (int)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
 end function get_logical

  integer function get_int(self,key,value) result(status)
    ! Retrieve the value of the requested instance variable
    type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
    character(len=*), intent(in) :: key                 !Descriptor key to retrieve
    integer, intent(out) :: value                       !Retrieved value
    
    ! Local variables
    integer :: error

    ! Set error status
    status = VGD_ERROR

    ! Map key name to derived-type element

    select case (up(key(1:KEY_LENGTH)))
    case ('DATE')
       value = self%rec%dateo
    case ('IG_1')
       value = self%rec%ig1
    case ('IG_2')
       value = self%rec%ig2
    case ('IG_3')
       value = self%rec%ig3
    case ('IG_4')
       value = self%rec%ig4
    case ('IP_1')
       value = self%ip1
    case ('IP_2')
       value = self%ip2
    case ('IP_3')
       value = self%rec%ip3
    case ('KIND')
       value = self%kind
    case ('VERS')
       value = self%version
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (int)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function get_int

  integer function get_int_1d(self,key,value) result(status)
    ! Retrieve the value of the requested instance variable
    type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
    character(len=*), intent(in) :: key                 !Descriptor key to retrieve
    integer, dimension(:), pointer :: value             !Retrieved value

    ! Internal variables
    integer :: istat,error

    ! Set error status
    status = VGD_ERROR

    ! Garbage collection
    if (associated(value)) deallocate(value)
    nullify(value)

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('VIP1')
       if (is_valid(self,ip1_m_valid)) then
          write(STDERR,*) 'ERROR: depricated key '//trim(key)//', use VIPM instead'
          return
       else
          write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (int 1D)'
          return
       endif
    case ('VIPM')
       if (is_valid(self,ip1_m_valid)) then
          istat = get_allocate(key,value,size(self%ip1_m))
          if (istat /= 0) return
          value = self%ip1_m
       else
          error = int(get_error(key))
          return
       endif
    case ('VIPT')
       if (is_valid(self,ip1_t_valid)) then
          istat = get_allocate(key,value,size(self%ip1_t))
          if (istat /= 0) return
          value = self%ip1_t
       else
          error = int(get_error(key))
          return
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (int 1D)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function get_int_1d

  integer function get_real(self,key,value) result(status)
    ! Retrieve the value of the requested instance variable
    type(vgrid_descriptor), intent(in) :: self   !Vertical descriptor instance
    character(len=*), intent(in) :: key          !Descriptor key to retrieve
    real, intent(out) :: value                   !Retrieved value

    ! Set error status
    status = VGD_ERROR

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('RC_1')
       if (is_valid(self,rcoef1_valid)) then
          value = self%rcoef1
       else
          value = dble(get_error(key))
          return
       endif
    case ('RC_2')
       if (is_valid(self,rcoef2_valid)) then
          value = self%rcoef2
       else
          value = dble(get_error(key))
          return
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (real)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function get_real

  integer function get_real_1d(self,key,value) result(status)
    ! Retrieve the value of the requested instance variable
    type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to retrieve
    real, dimension(:), pointer :: value        !Retrieved value

    ! Internal variables
    integer :: k,istat,error

    ! Set error status
    status = VGD_ERROR

    ! Garbage collection
    if (associated(value)) deallocate(value)
    nullify(value)
    
    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('VCDM')
       if (is_valid(self,ip1_m_valid)) then
          istat = get_allocate(key,value,size(self%ip1_m))
          if (istat /= 0) return
          call convip(k,value(1),self%kind,0,'',.false.)
          do k=1,size(value)
             call convip(self%ip1_m(k),value(k),self%kind,-1,'',.false.)
          enddo
       else
          error = int(get_error(key))
          return
       endif
    case ('VCDT')
       if (is_valid(self,ip1_t_valid)) then
          istat = get_allocate(key,value,size(self%ip1_t))
          if (istat /= 0) return
          call convip(k,value(1),self%kind,0,'',.false.)
          do k=1,size(value)
             call convip(self%ip1_t(k),value(k),self%kind,-1,'',.false.)
          enddo
       else
          error = int(get_error(key))
          return
       endif
    case ('VCRD')
       if (is_valid(self,ip1_m_valid)) then
          write(STDERR,*) 'ERROR: depricated key '//trim(key)//', use VCDM instead'
          return
       else
          error = int(get_error(key))
          return
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (real8 1D)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function get_real_1d

  integer function get_real8(self,key,value) result(status)
    ! Retrieve the value of the requested instance variable
    type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to retrieve
    real(kind=8), intent(out) :: value          !Retrieved value

    ! Set error status
    status = VGD_ERROR

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('PTOP')
       if (is_valid(self,ptop_8_valid)) then
          value = self%ptop_8
       else
          value = dble(get_error(key))
          return
       endif
    case ('PREF')
       if (is_valid(self,pref_8_valid)) then
          value = self%pref_8
       else
          value = dble(get_error(key))
          return
       endif
    case ('RC_1')
       if (is_valid(self,rcoef1_valid)) then
          value = self%rcoef1
       else
          value = dble(get_error(key))
          return
       endif
    case ('RC_2')
       if (is_valid(self,rcoef2_valid)) then
          value = self%rcoef2
       else
          value = dble(get_error(key))
          return
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (real8)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function get_real8

  integer function get_real8_1d(self,key,value) result(status)
    ! Retrieve the value of the requested instance variable
    type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to retrieve
    real(kind=8), dimension(:), pointer :: value !Retrieved value

    ! Internal variables
    integer :: istat,error

    ! Set error status
    status = VGD_ERROR

    ! Garbage collection
    if (associated(value)) deallocate(value)
    nullify(value)

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('CA_M')
       if (is_valid(self,a_m_8_valid)) then
          istat = get_allocate(key,value,size(self%a_m_8))
          if (istat /= 0) return
          value = self%a_m_8
       else
          error = int(get_error(key))
          return
       endif
    case ('CB_M')
       if (is_valid(self,b_m_8_valid)) then
          istat = get_allocate(key,value,size(self%b_m_8))
          if (istat /= 0) return
          value = self%b_m_8
       else
          error = int(get_error(key))
          return
       endif
    case ('CA_T')
       if (is_valid(self,a_t_8_valid)) then
          istat = get_allocate(key,value,size(self%a_t_8))
          if (istat /= 0) return
          value = self%a_t_8
       else
          error = int(get_error(key))
          return
       endif
    case ('CB_T')
       if (is_valid(self,b_t_8_valid)) then
          istat = get_allocate(key,value,size(self%b_t_8))
          if (istat /= 0) return
          value = self%b_t_8
       else
          error = int(get_error(key))
          return
       endif
    case ('COFA')
       if (is_valid(self,a_m_8_valid)) then
          istat = get_allocate(key,value,size(self%a_m_8))
          if (istat /= 0) return
          value = self%a_m_8
       else
          error = int(get_error(key))
          return
       endif
    case ('COFB')
       if (is_valid(self,b_m_8_valid)) then
          istat = get_allocate(key,value,size(self%b_m_8))
          if (istat /= 0) return
          value = self%b_m_8
       else
          error = int(get_error(key))
          return
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (real8 1D)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function get_real8_1d

  integer function get_real8_3d(self,key,value) result(status)
    ! Retrieve the value of the requested instance variable
    type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to retrieve
    real(kind=8), dimension(:,:,:), pointer :: value !Retrieved value

    ! Internal variables
    integer :: istat

    ! Set error status
    status = VGD_ERROR

    ! Garbage collection
    if (associated(value)) deallocate(value)
    nullify(value)

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('VTBL')
       istat = get_allocate(key,value,shape(self%table))
       if (istat /= 0) return
       value = self%table
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (real8 3D)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function get_real8_3d

  integer function get_char(self,key,value) result(status)
    ! Retrieve the value of the requested instance variable
    type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to retrieve
    character(len=*), intent(out) :: value      !Retrieved value
    
    ! Local variables
    integer :: error

    ! Set error status
    status = VGD_ERROR

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('ETIK')
       value = self%rec%etiket
    case ('NAME')
       value = self%rec%nomvar
    case ('RFLD')
       if (is_valid(self,ref_name_valid)) then
          value = self%ref_name
       else
          write(value,'(i8)') get_error(key)
          return
       endif
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_get (char)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function get_char

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Put methods

  integer function put_int(self,key,value) result(status)
    ! Set the value of the requested instance variable
    type(vgrid_descriptor), intent(inout) :: self !Vertical descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    integer, intent(in) :: value                !Value to set
    
    ! Local variables
    integer :: error

    ! Set error status
    status = VGD_ERROR

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('DATE')
       self%rec%dateo = value
    case ('IG_1')
       self%rec%ig1 = value
    case ('IG_2')
       self%rec%ig2 = value
    case ('IG_3')
       self%rec%ig3 = value
    case ('IG_4')
       self%rec%ig4 = value
    case ('IP_1')
       self%ip1 = value
    case ('IP_2')
       self%ip2 = value
    case ('IP_3')
       self%rec%ip3 = value
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (int)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function put_int

  integer function put_int_1d(self,key,value) result(status)
    ! Set the value of the requested instance variable
    type(vgrid_descriptor), intent(inout) :: self       !Vertical descriptor instance
    character(len=*), intent(in) :: key                 !Descriptor key to set
    integer, dimension(:), pointer :: value             !Value to set

    ! Local variables
    integer :: error
    
    ! Set error status
    status = VGD_ERROR

    ! Check for valid value
    if (.not.associated(value)) then
       write(STDERR,*) 'ERROR: unallocated value sent to gd_put for '//trim(key)
       return
    endif

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('VIPM')
       if (.not.size_ok(self%ip1_m,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%ip1_m = value
       if (.not.is_valid(self,ip1_m_valid)) status = put_error(key)
    case ('VIPT')
       if (.not.size_ok(self%ip1_t,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%ip1_t = value
       if (.not.is_valid(self,ip1_t_valid)) status = put_error(key)
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (real8 1D)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function put_int_1d

  integer function put_real_1d(self,key,value) result(status)
    ! Set the value of the requested instance variable
    type(vgrid_descriptor), intent(inout) :: self!Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    real, dimension(:), pointer :: value !Value to set

    ! Local variables
    integer :: error
    
    ! Set error status
    status = VGD_ERROR

    ! Check for valid value
    if (.not.associated(value)) then
       write(STDERR,*) 'ERROR: unallocated value sent to gd_put for '//trim(key)
       return
    endif

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('VCDM')
       write(STDERR,*) 'ERROR: '//trim(key)//' cannot be set - modify VIPM instead'
       return
    case ('VCDT')
       write(STDERR,*) 'ERROR: '//trim(key)//' cannot be set - modify VIPT instead'
       return
    case ('VCRD')
       write(STDERR,*) 'ERROR: '//trim(key)//' cannot be set - modify VIPM instead'
       return
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (real8 1D)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function put_real_1d

  integer function put_real8(self,key,value) result(status)
    ! Set the value of the requested instance variable
    type(vgrid_descriptor), intent(inout) :: self!Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    real(kind=8), intent(in) :: value           !Value to set

    ! Local variables
    integer :: error

    ! Set error status
    status = VGD_ERROR

    ! Map key name to derived-type element
    error = VGD_OK
    select case (up(key(1:KEY_LENGTH)))
    case ('PTOP')
       self%ptop_8 = value
       if (.not.is_valid(self,ptop_8_valid)) error = put_error(key)
    case ('PREF')
       self%pref_8 = value
       if (.not.is_valid(self,pref_8_valid)) error = put_error(key)
    case ('RC_1')
       self%rcoef1 = value
       if (.not.is_valid(self,rcoef1_valid)) error = put_error(key)
    case ('RC_2')
       self%rcoef2 = value
       if (.not.is_valid(self,rcoef2_valid)) error = put_error(key)
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (real8)'
       return
    end select

    ! Check for sets of invalid values
    if (error /= VGD_OK) return

    ! Set status and return
    status = VGD_OK
    return
  end function put_real8

  integer function put_real8_1d(self,key,value) result(status)
    ! Set the value of the requested instance variable
    type(vgrid_descriptor), intent(inout) :: self!Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    real(kind=8), dimension(:), pointer :: value !Value to set

    ! Local variables
    integer :: error
    
    ! Set error status
    status = VGD_ERROR

    ! Check for valid value
    if (.not.associated(value)) then
       write(STDERR,*) 'ERROR: unallocated value sent to gd_put for '//trim(key)
       return
    endif

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('CA_M')
       if (.not.size_ok(self%a_m_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%a_m_8 = value
       if (.not.is_valid(self,a_m_8_valid)) status = put_error(key)
    case ('CB_M')
       if (.not.size_ok(self%b_m_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%b_m_8 = value
       if (.not.is_valid(self,b_m_8_valid)) status = put_error(key)
    case ('CA_T')
       if (.not.size_ok(self%a_t_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%a_t_8 = value
       if (.not.is_valid(self,a_t_8_valid)) status = put_error(key)
    case ('CB_T')
       if (.not.size_ok(self%b_t_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%b_t_8 = value
       if (.not.is_valid(self,b_t_8_valid)) status = put_error(key)
    case ('COFA')
       if (.not.size_ok(self%a_m_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%a_m_8 = value
       if (.not.is_valid(self,a_m_8_valid)) status = put_error(key)
    case ('COFB')
       if (.not.size_ok(self%b_m_8,value)) then
          write(STDERR,*) 'ERROR: value does not match '//trim(key)//' size in gd_put'
          return
       endif
       self%b_m_8 = value
       if (.not.is_valid(self,b_m_8_valid)) status = put_error(key)
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (real8 1D)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function put_real8_1d

  integer function put_real8_3d(self,key,value) result(status)
    ! Set the value of the requested instance variable
    type(vgrid_descriptor), intent(inout) :: self!Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    real(kind=8), dimension(:,:,:), pointer :: value !Value to set

    ! Set error status
    status = VGD_ERROR

    ! Check for valid value
    if (.not.associated(value)) then
       write(STDERR,*) 'ERROR: unallocated value sent to gd_put for'//trim(key)
       return
    endif

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('VTBL')
       if (.not.size_ok(self%table,value)) then
          write(STDERR,*) 'ERROR: value does not match table size in gd_put'
          return
       endif
       self%table = value
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (real8 3D)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function put_real8_3d

  integer function put_char(self,key,value) result(status)
    ! Set the value of the requested instance variable
    type(vgrid_descriptor), intent(inout) :: self!Descriptor instance
    character(len=*), intent(in) :: key         !Descriptor key to set
    character(len=*), intent(in) :: value       !Value to set

    ! Internal variables
    integer :: error

    ! Set error status
    status = VGD_ERROR

    ! Map key name to derived-type element
    select case (up(key(1:KEY_LENGTH)))
    case ('ETIK')
       self%rec%etiket = value
    case ('NAME')
       self%rec%nomvar = value
    case ('RFLD')
       self%ref_name = value
       if (.not.is_valid(self,ref_name_valid)) error = put_error(key)
    case DEFAULT
       write(STDERR,*) 'ERROR: invalid key '//trim(key)//' given to gd_put (char)'
       return
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function put_char

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Dump contents

  integer function print_desc(self,stdout) result(status)
    ! Dump plain text grid descriptor information to the requested file unit
    type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
    integer, intent(in), optional :: stdout     !Output unit to write to [6]

    ! Internal variables
    integer :: my_stdout,stat,nk,k
    character(len=64) :: hr
    character(len=VGD_LEN_NAME) :: name

    ! Set error status
    status = VGD_ERROR

    ! Set default values
    my_stdout = 6
    if (present(stdout)) my_stdout = stdout

    ! Create horizontal rule
    hr = '-------------------------------------------------------'

    ! Dump general descriptor information
    write(my_stdout,*) '-- Vertical Grid Descriptor Information --'
    write(my_stdout,*) '  ip1=',self%ip1
    write(my_stdout,*) '  ip2=',self%ip2
    write(my_stdout,*) trim(hr)

    ! Dump vertical descriptor information
    have_descriptor: if (found_descriptor(self)) then
       write(my_stdout,*)'  Descriptor Nomvar: ',trim(self%rec%nomvar)
       write(my_stdout,'(a,i2,a,i3)')'   level kind =',self%kind,', level version = ',self%version
       if (is_valid(self,ptop_8_valid))  write(my_stdout,*)'  ptop=',self%ptop_8,'Pa'
       if (is_valid(self,pref_8_valid))  write(my_stdout,*)'  pref=',self%pref_8,'Pa'       
       if (is_valid(self,rcoef1_valid))  write(my_stdout,*)'  rcoef1=',self%rcoef1
       if (is_valid(self,rcoef2_valid))  write(my_stdout,*)'  rcoef2=',self%rcoef2
       if (is_valid(self,ref_name_valid))write(my_stdout,*)'  Surface field nomvar ',self%ref_name
       select case (self%vcode)
       case (1001)
          nk=size(self%ip1_m)
          write(my_stdout,*)'  Number of sigma levels',nk
          write(my_stdout,*)'  Equation to compute hydrostatic pressure (pi): pi = B * P0*100'
       case (1002)
          nk=size(self%ip1_m)
          write(my_stdout,*)'  Number of levels eta levels',nk
          write(my_stdout,*)'  Equation to compute hydrostatic pressure (pi): pi = A + B * P0*100'
       case (2001)
          nk=size(self%ip1_m)
          write(my_stdout,*)'  Number of pressure levels',nk
          write(my_stdout,*)'  Equation to pressure (P): P = A'
       case (5001)
          nk=size(self%ip1_m)
          write(my_stdout,*)'  Number of levels hybrid levels',nk
          write(my_stdout,*)'  Equation to compute hydrostatic pressure (pi): pi = A + B * P0*100'
       case (5002)
          nk=size(self%ip1_m)
          write(my_stdout,*)'  Number of levels hybrid levels (momentum levels)',nk-1
          write(my_stdout,*)'  Equation to compute hydrostatic pressure (pi): ln(pi) = A + B * ln(P0*100/pref)'
       end select
       
       if (is_valid(self,ip1_m_valid))then
          nk=size(self%ip1_m)
          write(my_stdout,*)'  Momentum levels ip1, A, B:'
          do k=1,nk
             write(my_stdout,*)self%ip1_m(k),self%a_m_8(k),self%b_m_8(k)
          enddo
       endif
       if (is_valid(self,ip1_t_valid))then
          nk=size(self%ip1_t)
          write(my_stdout,*)'  Thermodynamic levels ip1, A, B:'
          do k=1,nk
             write(my_stdout,*)self%ip1_t(k),self%a_t_8(k),self%b_t_8(k)
          enddo
       endif
    else
       write(my_stdout,*) '* No Vertical Grid Descriptor Information Found'
    endif have_descriptor

    ! Set status and return
    status = VGD_OK
    return
  end function print_desc

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Write descriptors
  
  integer function write_desc(self,unit,format) result(status)     
    ! Write descriptors to the requested file
    type(vgrid_descriptor), intent(in) :: self  !Vertical descriptor instance
    integer, intent(in) :: unit                 !File unit to write to
    character(len=*), intent(in) :: format      !File format ('fst' or 'bin')

    ! Local variables
    integer :: error,ni,nj,nk,fstecr
    real :: dummy

    ! Set error status
    status = VGD_ERROR

    ! Array size from table
    ni=size(self%table,dim=1)
    nj=size(self%table,dim=2)
    nk=size(self%table,dim=3)

    ! Write to the desired output file type
    select case (trim(up(format)))

    ! Write to an RPN Standard file
    case ('FST')
    error=fstecr(self%table,dummy,-64,unit, &
         self%rec%dateo,self%rec%deet,self%rec%npas, &
         ni,nj,nk,self%ip1,self%ip2,self%rec%ip3, &
         self%rec%typvar,self%rec%nomvar,self%rec%etiket,self%rec%grtyp, &
         self%rec%ig1,self%rec%ig2,self%rec%ig3,self%rec%ig4,5,.true.)
    if(error < 0)then
       write(STDERR,*) 'ERROR: problem with fstecr in write_desc'
       return
    endif

    ! Write to a Fortran binary file
    case ('BIN')
       write(unit) ni,nj,nk
       write(unit) self%table

    ! Warn user for unknown format
    case DEFAULT
       write(STDERR,*) 'WARNING: no write done for unknown format ',trim(format)
    end select

    ! Set status and return
    status = VGD_OK
    return
  end function write_desc

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Compute vertical levelling

  integer function levels_toplevel(unit,fstkeys,levels,in_log) result(status)
    ! Top-level interface for computing physical levelling information
    integer, intent(in) :: unit                         !File unit associated with the key
    integer, dimension(:), intent(in) :: fstkeys        !Key of prototype field
    real, dimension(:,:,:), pointer :: levels           !Physical level values
    logical, optional, intent(in) :: in_log             !Compute levels in ln() [.false.]

    ! Local variables
    integer :: error,ig1,ig2,ig3,i
    character(len=LONG_STRING) :: grtyp
    logical :: construct,multiple_grids,my_in_log
    type(vgrid_descriptor) :: gd
    type(FSTD_ext) :: var

    ! Set error status
    status = VGD_ERROR

    ! Set default values
    my_in_log = .false.
    if (present(in_log)) my_in_log = in_log

    ! Construct appropriate grid_descriptor object (rebuild if new ig1-3 values are found)
    multiple_grids = .false.
    grids: do i=1,size(fstkeys)
       error = my_fstprm(fstkeys(i),var)
       if (error /= VGD_OK) then
          write(STDERR,*) 'ERROR: error return from fstprm wrapper for fst key ',fstkeys(i)
          return
       endif
       if (i==1) then
          ig1 = var%ig1
          ig2 = var%ig2
          ig3 = var%ig3
          grtyp = var%grtyp
       endif
       if (var%ig1 /= ig1 .or. var%ig2 /= ig2 .or. var%ig3 /= ig3 .or. trim(var%grtyp) /= trim(grtyp)) then
          write(STDERR,*) 'ERROR: multiple grids defined in fstkeys vector'
          return
       endif
    enddo grids

    ! Create grid descriptor instance and call level calculator
    if (any(MATCH_GRTYP == grtyp)) then
       error = new_read(gd,unit=unit,format='fst',ip1=ig1,ip2=ig2)
    else
       error = new_read(gd,unit=unit,format='fst',ip1=-1,ip2=-1)
    endif
    if (error /= VGD_OK) then
       write(STDERR,*) 'ERROR: cannot build grid descriptor instance for fst key ',fstkeys(i)
       return
    endif
    error = levels_readref(gd,unit=unit,fstkeys=fstkeys,levels=levels,in_log=my_in_log)
    if (error /= VGD_OK) then
       write(STDERR,*) 'ERROR: problem computing level information for fst key ',fstkeys(i)
       return
    endif

    ! Set status and return
    status = VGD_OK
    return
  end function levels_toplevel

  integer function levels_readref(self,unit,fstkeys,levels,in_log) result(status)
    ! Reading referent, compute physical levelling information from the vertical description
    type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
    integer, intent(in) :: unit                         !File unit associated with the key
    integer, dimension(:), intent(in) :: fstkeys        !Key of prototype field
    real, dimension(:,:,:), pointer :: levels           !Physical level values
    logical, optional, intent(in) :: in_log             !Compute levels in ln() [.false.]

    ! Internal variables
    integer :: fstinf,ni,nj,nk,sfc_key,istat,error,fstluk,i
    integer, dimension(size(fstkeys)) :: ip1_list
    type(FSTD_ext) prmk,prm_p0,prm_check
    real, dimension(:,:), pointer :: p0
    logical :: my_in_log

    ! Set error status
    status = VGD_ERROR

    ! Set default values
    my_in_log = .false.
    if (present(in_log)) my_in_log=in_log

    ! Check input keys
    istat=my_fstprm(fstkeys(1),prmk)
    if(istat < 0)then
       write(STDERR,*) 'ERROR: problem with my_fstprm in levels_readref'
    endif
    check_times: do i=1,size(fstkeys)
       istat=my_fstprm(fstkeys(i),prm_check)
       ip1_list(i) = prm_check%ip1
       if (prm_check%datev /= prmk%datev) then
          write(STDERR,*) 'ERROR: multiple valid times given in fstkeys vector'
          return
       endif
       if (prm_check%ig1 /= prmk%ig1 .or. prm_check%ig2 /= prmk%ig2) then
          write(STDERR,*) 'ERROR: multiple grids given in fstkeys vector'
          return
       endif
    enddo check_times
    if (self%match_ipig) then
       if (prmk%ig1 /= self%ip1 .or. prmk%ig2 /= self%ip2) then
          write(STDERR,*) 'ERROR: fstkeys do not correspond to the correct grid descriptor'
          return
       endif
    endif

    ! Check surface field if needed
    sfc_valid: if (is_valid(self,ref_name_valid)) then
       sfc_key = fstinf(unit,ni,nj,nk,prmk%datev,prmk%etiket,-1,prmk%ip2,prmk%ip3,' ',self%ref_name)
       if(sfc_key < 0)then
          write(STDERR,*) 'ERROR: cannot find ',self%ref_name,' for :'
          write(STDERR,*) 'datev=',prmk%datev,' etiket=',prmk%etiket,' ip2=',prmk%ip2,' ip3=',prmk%ip3
          return   
       endif
       istat=my_fstprm(sfc_key,prm_p0)
       if(prm_p0%ni.ne.prmk%ni.or.prm_p0%nj.ne.prmk%nj)then
          write(STDERR,*) 'ERROR: horizontal grid mismatch for '//trim(self%ref_name),ni,nj,' vs',prmk%ni,prmk%nj
          return
       endif
       if (self%match_ipig) then
          if (prm_p0%ig1 /= self%ip1 .or. prm_p0%ig2 /= self%ip2) then
             write(STDERR,*) 'ERROR: sfc_field ig1-2 do not correspond to the correct grid descriptor'
             return
          endif
       endif
       allocate(p0(ni,nj),stat=error)
       if (error /= 0) then
          write(STDERR,*) 'ERROR: cannot allocate space for p0 in levels_readref'
          return
       endif
       error = fstluk(p0,sfc_key,ni,nj,nk)
       if(error < 0 )then
          write(STDERR,*) 'ERROR: problem with fstluk '//trim(self%ref_name)//' in levels_readref'
          return
       endif
       if (trim(self%ref_name) == 'P0') p0 = p0*100. !convert mb to Pa
    else
       allocate(p0(1,1),stat=error)
       if (error /= 0) then
          write(STDERR,*) 'ERROR: cannot allocate space for p0 in levels_readref'
          return
       endif
       p0 = VGD_MISSING
    endif sfc_valid
   
    ! Wrap call to level calculator
    error = levels_withref(self,sfc_field=p0,ip1_list=ip1_list,levels=levels,in_log=my_in_log)
    if (error /= VGD_OK) then
       write(STDERR,*) 'ERROR: got error return from levels_withref in levels_readref'
       return
    endif

    ! Set status and return
    status = VGD_OK
    return
  end function levels_readref

  integer function levels_withref_prof(self,ip1_list,levels,sfc_field,in_log) result(status)
     ! profile wraper for levels_withref
     type(vgrid_descriptor), intent(in) :: self                  !Vertical descriptor instance
     integer, dimension(:), intent(in) :: ip1_list               !Key of prototype field
     real, dimension(:), pointer :: levels                       !Physical level values
     real, optional, intent(in) :: sfc_field                     !Surface field reference for coordinate [none]
     logical, optional, intent(in) :: in_log                     !Compute levels in ln() [.false.]          
     
     ! Local variables
     integer :: error,nk
     real, dimension(:,:), pointer :: sfc_field_2d
     real, dimension(:,:,:), pointer :: levels_3d
     
     ! Set error status
     status = VGD_ERROR

     nk=size(ip1_list)

     allocate(sfc_field_2d(1,1),levels_3d(1,1,nk),stat=error)
     if (error /= 0) then
        write(STDERR,*) 'ERROR: cannot allocate space for p0/levels in levels_withref_prof'
        return
     endif
     sfc_field_2d=sfc_field
     ! Wrap call to level calculator    
     error = levels_withref(self,sfc_field=sfc_field_2d,ip1_list=ip1_list,levels=levels_3d,in_log=in_log)    
     if (error /= 0) then
        write(STDERR,*) 'ERROR: problem with levels_withref in levels_withref_prof'
        return
     endif
     if (associated(levels)) then
        if (size(levels) /= nk) then
           write (STDERR,*) 'WARNING: levels array size error - will be reallocated'
        endif
        deallocate(levels)
     endif
     allocate(levels(nk),stat=error)
     if (error /= 0) then
        write(STDERR,*) 'ERROR: cannot allocate space for levels in levels_withref_prof'
        return
     endif
     levels=levels_3d(1,1,1:nk)

     ! Set status and return
     status = VGD_OK
     return

  end function levels_withref_prof

  integer function levels_withref(self,ip1_list,levels,sfc_field,in_log) result(status)
    ! Given referent, compute physical levelling information from the vertical description
    type(vgrid_descriptor), intent(in) :: self                  !Vertical descriptor instance
    integer, dimension(:), intent(in) :: ip1_list               !Key of prototype field
    real, dimension(:,:,:), pointer :: levels                   !Physical level values
    real, dimension(:,:), optional, intent(in) :: sfc_field     !Surface field reference for coordinate [none]
    logical, optional, intent(in) :: in_log                     !Compute levels in ln() [.false.]
   
    ! Local variables
    integer kind,version,istat,ni,nj,nk,error
    logical :: my_in_log

    ! Set error status
    status = VGD_ERROR

    ! Set default values
    my_in_log = .false.
    if (present(in_log)) my_in_log = in_log
    
    ! Set size of output and allocate space
    if (present(sfc_field)) then
       ni = size(sfc_field,dim=1); nj = size(sfc_field,dim=2); nk = size(ip1_list)
    else
      if (is_valid(self,ref_name_valid)) then
         write(STDERR,*) 'ERROR: reference field must be provided to levels_withref'
         return
      else
         ni = 1; nj = 1; nk = size(ip1_list)
      endif
    endif
    if (associated(levels)) then
       if (size(levels,dim=1) /= ni .or. size(levels,dim=2) /= nj .or. size(levels,dim=3) /= nk) then
          write (STDERR,*) 'WARNING: levels array size error - will be reallocated'
       endif
       deallocate(levels)
    endif
    allocate(levels(ni,nj,nk),stat=error)
    if (error /= 0) then
       write(STDERR,*) 'ERROR: cannot allocate space for levels in levels_withref'
       return
    endif

    ! Compute levels for known vertical coordinates
    select case (self%vcode)
    case (1001)
       istat = compute_pressure_1001(self,sfc_field,ip1_list,levels,my_in_log)
    case (1002)
       istat = compute_pressure_1002(self,sfc_field,ip1_list,levels,my_in_log)
    case (2001)
       istat = compute_pressure_2001(self,ip1_list,levels,my_in_log)
    case (5001)
       istat = compute_pressure_5001(self,sfc_field,ip1_list,levels,my_in_log)
    case (5002)
       istat = compute_pressure_5002(self,sfc_field,ip1_list,levels,my_in_log)
    case DEFAULT
       istat = get_version_info(self,kind,version)
       write(STDERR,*) 'ERROR: kind or version invalid :',kind,version
       return 
    end select
    if (istat /= VGD_OK) then
       write(STDERR,*) 'ERROR: error computing pressure in levels_withref'
       return
    endif

    ! Set status and return
    status = VGD_OK
    return
  end function levels_withref

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Convert string to upper-case

  function up (string) result(upper_string)
    ! Convert a string to all upper-case
    character(len=*), intent(in) :: string      !Input string to upper-case
    character(len=LONG_STRING) :: upper_string  !Upper-cased result
    integer :: i
    if (len_trim(string) > len(upper_string)) then
       write(STDERR,*) 'WARNING: long string truncated in up() ',trim(string)
    endif
    upper_string = string
    do i = 1,len_trim(string)
       if (string(i:i) >= 'a' .and. string(i:i) <= 'z') then
          upper_string(i:i) = achar(iachar(string(i:i)) - 32)
       endif
    enddo
    return
  end function up

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Check array sizes

  logical function size_ok_i1d(p1,p2) result(ok)
    ! Check size matching for 3d real8 arrays
    integer, dimension(:), pointer :: p1        !Input pointer 1
    integer, dimension(:), pointer :: p2        !Input pointer 2
    ok = .false.
    if (.not.associated(p1) .or. .not.associated(p2)) then
       write(STDERR,*) 'ERROR: unallocated pointer to check in size_ok'
       return
    endif
    if (size(p1,dim=1) == size(p2,dim=1)) ok = .true.
    return
  end function size_ok_i1d

  logical function size_ok_r81d(p1,p2) result(ok)
    ! Check size matching for 3d real8 arrays
    real(kind=8), dimension(:), pointer :: p1   !Input pointer 1
    real(kind=8), dimension(:), pointer :: p2   !Input pointer 2
    ok = .false.
    if (.not.associated(p1) .or. .not.associated(p2)) then
       write(STDERR,*) 'ERROR: unallocated pointer to check in size_ok'
       return
    endif
    if (size(p1,dim=1) == size(p2,dim=1)) ok = .true.
    return
  end function size_ok_r81d

  logical function size_ok_r83d(p1,p2) result(ok)
    ! Check size matching for 3d real8 arrays
    real(kind=8), dimension(:,:,:), pointer :: p1 !Input pointer 1
    real(kind=8), dimension(:,:,:), pointer :: p2 !Input pointer 2
    ok = .false.
    if (.not.associated(p1) .or. .not.associated(p2)) then
       write(STDERR,*) 'ERROR: unallocated pointer to check in size_ok'
       return
    endif
    if ( size(p1,dim=1) == size(p2,dim=1) .and. &
         size(p1,dim=2) == size(p2,dim=2) .and. &
         size(p1,dim=3) == size(p2,dim=3)) ok = .true.
    return
  end function size_ok_r83d

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Encoding functions

  integer function encode_vert_1001(self,nk) result(status)
     type(vgrid_descriptor), intent(inout) :: self      !Vertical descriptor instance
     integer, intent(in) :: nk                          !Number of levels

     ! Local variables
     integer :: nn,error,k,ind
     integer, parameter :: skip=2
     real*8 :: for_char_8

     ! Set error status
     status = VGD_ERROR

     ! Allocate table space
     if (associated(self%table)) deallocate(self%table)         
     allocate(self%table(3,nk+skip,1),stat=error)
     if(error < 0)then
        write(STDERR,*) 'ERROR: cannot allocate self%table in encode_vert_1001'
        return
     endif

     ! Fill standard file record entries
     error = fstd_init(self,etiket='ETA_GEMV3',   &
          ig2=0,            &
          ig3=0,         &
          ig4=0)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: cannot initialize fstd record entries'
        return
     end if
     self%ref_name="P0"
     
     ! Vector size checks
     nn=size(self%ip1_m)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for ip1_m, is ',nn,'should be ',nk
        return
     endif
     nn=size(self%a_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for a_m_8, is ',nn,'should be ',nk
        return
     endif
     nn=size(self%b_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for b_m_8, is ',nn,'should be ',nk
        return
     endif
     error = flip_transfer(self%ref_name,for_char_8)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: flip_transfer function returned an error code from encode ',error
        return
     endif

     ! Fill header
     self%table(1:3,1,1)=(/dble(self%kind),dble(self%version),dble(skip)/)
     self%table(1:3,2,1)=(/for_char_8     , 0.d0             ,0.d0/)

     ! Fill level data
     do k=1,nk
        ind=k+skip
        self%table(1:3,ind,1)=(/dble(self%ip1_m(k)),self%a_m_8(k),self%b_m_8(k)/)
     enddo     

     ! Set status and return
     status = VGD_OK
  end function encode_vert_1001

  integer function encode_vert_1002(self,nk) result(status)
     type(vgrid_descriptor), intent(inout) :: self      !Vertical descriptor instance
     integer, intent(in) :: nk                          !Number of levels

     ! Local variables
     integer :: nn,error,k,ind
     integer, parameter :: skip=2
     real*8 :: for_char_8

     ! Set error status
     status = VGD_ERROR

     ! Allocate table space
     if (associated(self%table)) deallocate(self%table)         
     allocate(self%table(3,nk+skip,1),stat=error)
     if(error < 0)then
        write(STDERR,*) 'ERROR: cannot allocate self%table in encode_vert_1002'
        return
     endif

     ! Fill standard file record entries
     error = fstd_init(self,etiket='ETA_GEMV3',   &
          ig2=nint(self%ptop_8*10.d0),            &
          ig3=0,         &
          ig4=0)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: cannot initialize fstd record entries'
        return
     end if
     self%ref_name="P0"
     
     ! Vector size checks
     nn=size(self%ip1_m)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for ip1_m, is ',nn,'should be ',nk
        return
     endif
     nn=size(self%a_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for a_m_8, is ',nn,'should be ',nk
        return
     endif
     nn=size(self%b_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for b_m_8, is ',nn,'should be ',nk
        return
     endif
     error = flip_transfer(self%ref_name,for_char_8)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: flip_transfer function returned an error code from encode ',error
        return
     endif

     ! Fill header
     self%table(1:3,1,1)=(/dble(self%kind),dble(self%version),dble(skip)/)
     self%table(1:3,2,1)=(/self%ptop_8    ,for_char_8, 0.d0/)

     ! Fill level data
     do k=1,nk
        ind=k+skip
        self%table(1:3,ind,1)=(/dble(self%ip1_m(k)),self%a_m_8(k),self%b_m_8(k)/)
     enddo     

     ! Set status and return
     status = VGD_OK
  end function encode_vert_1002

  integer function encode_vert_2001(self) result(status)
     type(vgrid_descriptor), intent(inout) :: self      !Vertical descriptor instance

     ! Local variables
     integer :: nn,ip1,nk,k,ind,error
     integer, parameter :: skip=1

     ! Set error status
     status = VGD_ERROR

     ! Allocate table space
     nk = size(self%a_m_8)
     if (associated(self%table)) deallocate(self%table)         
     allocate(self%table(3,nk+skip,1),stat=error)
     if(error < 0)then
        write(STDERR,*) 'ERROR: cannot allocate self%table in encode_vert_2001'
        return
     endif

     ! Fill standard file record entries
     error = fstd_init(self,etiket='PRESSURE',ig2=0,ig3=0,ig4=0)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: cannot initialize fstd record entries'
        return
     end if

     ! Vector size checks
     nn=size(self%a_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for a_m_8, is ',nn,'should be ',nk
        return
     endif
     
     ! Fill header
     self%table(1:3,1,1)=(/dble(self%kind),dble(self%version),dble(skip)/)

     ! Fill pressure level data
     do k=1,nk
        ind=k+skip
        self%table(1:3,ind,1)=(/dble(self%ip1_m(k)),self%a_m_8(k),self%b_m_8(k)/)
     enddo

     ! Set status and return
     status = VGD_OK
     return
   end function encode_vert_2001

  integer function encode_vert_5001(self,nk) result(status)
     type(vgrid_descriptor), intent(inout) :: self      !Vertical descriptor instance
     integer, intent(in) :: nk                          !Number of levels

     ! Local variables
     integer :: nn,error,k,ind
     integer, parameter :: skip=3
     real*8 :: for_char_8

     ! Set error status
     status = VGD_ERROR

     ! Allocate table space
     if (associated(self%table)) deallocate(self%table)         
     allocate(self%table(3,nk+skip,1),stat=error)
     if(error < 0)then
        write(STDERR,*) 'ERROR: cannot allocate self%table in encode_vert_5001'
        return
     endif

     ! Fill standard file record entries
     error = fstd_init(self,etiket='HYB_GEMV3',   &
          ig2=nint(self%ptop_8*10.d0),            &
          ig3=nint(self%rcoef1*100.),           &
          ig4=0)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: cannot initialize fstd record entries'
        return
     end if
     self%ref_name="P0"
     
     ! Vector size checks
     nn=size(self%ip1_m)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for ip1_m, is ',nn,'should be ',nk
        return
     endif
     nn=size(self%a_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for a_m_8, is ',nn,'should be ',nk
        return
     endif
     nn=size(self%b_m_8)
     if(nn.ne.nk)then
        write(STDERR,*) 'ERROR: wrong size for b_m_8, is ',nn,'should be ',nk
        return
     endif
     error = flip_transfer(self%ref_name,for_char_8)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: flip_transfer function returned an error code from encode ',error
        return
     endif

     ! Fill header
     self%table(1:3,1,1)=(/dble(self%kind),dble(self%version),dble(skip)/)
     self%table(1:3,2,1)=(/self%ptop_8    ,self%pref_8       ,dble(self%rcoef1)/)     
     self%table(1:3,3,1)=(/for_char_8        ,0.d0                 ,0.d0/)

     ! Fill level data
     do k=1,nk
        ind=k+skip
        self%table(1:3,ind,1)=(/dble(self%ip1_m(k)),self%a_m_8(k),self%b_m_8(k)/)
     enddo     

     ! Set status and return
     status = VGD_OK
  end function encode_vert_5001

  integer function encode_vert_5002(self,nk) result(status)
     type(vgrid_descriptor), intent(inout) :: self      !Vertical descriptor instance
     integer, intent(in) :: nk                          !Number of levels

     ! Local variables
     integer :: nn,error,k,ind
     integer, parameter :: skip=3
     real*8 :: for_char_8
     character(len=8) :: ref_name,ref_name_flip

     ! Set error status
     status = VGD_ERROR

     ! Allocate table space
     if (associated(self%table)) deallocate(self%table)         
     allocate(self%table(3,(2*nk+3)+skip,1),stat=error)
     if(error < 0)then
        write(STDERR,*) 'ERROR: cannot allocate self%table in encode_vert_5002'
        return
     endif

     ! Fill standard file record entries
     error = fstd_init(self,etiket='STG_CP_GEMV4',   &
          ig2=nint(self%ptop_8*10.d0),               &
          ig3=nint(self%rcoef1*100.),            &
          ig4=nint(self%rcoef2*100.))
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: cannot initialize fstd record entries'
        return
     end if
     self%ref_name="P0"
     
     ! Vector size checks
     nn=size(self%ip1_m)
     if(nn.ne.nk+1)then
        write(STDERR,*) 'ERROR: wrong size for ip1_m, is ',nn,'should be ',nk+1
        return
     endif
     nn=size(self%a_m_8)
     if(nn.ne.nk+1)then
        write(STDERR,*) 'ERROR: wrong size for a_m_8, is ',nn,'should be ',nk+1
        return
     endif
     nn=size(self%b_m_8)
     if(nn.ne.nk+1)then
        write(STDERR,*) 'ERROR: wrong size for b_m_8, is ',nn,'should be ',nk+1
        return
     endif
     nn=size(self%ip1_t)
     if(nn.ne.nk+2)then
        write(STDERR,*) 'ERROR: wrong size for ip1_t, is ',nn,'should be ',nk+2
        return
     endif
     nn=size(self%a_t_8)
     if(nn.ne.nk+2)then
        write(STDERR,*) 'ERROR: wrong size for a_t_8, is ',nn,'should be ',nk+2
        return
     endif
     nn=size(self%b_t_8)
     if(nn.ne.nk+2)then
        write(STDERR,*) 'ERROR: wrong size for b_t_8, is ',nn,'should be ',nk+2
        return
     endif
     if (len_trim(self%ref_name) > len(ref_name)) then
        write(STDERR,*) 'ERROR: reference field name '//trim(self%ref_name)//' longer than limit: ',len(ref_name)
        return
     endif
     error = flip_transfer(self%ref_name,for_char_8)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: flip_transfer function returned error code from encode ',error
        return
     endif

     ! Fill header
     self%table(1:3,1,1)=(/dble(self%kind)  ,dble(self%version),dble(skip)/)
     self%table(1:3,2,1)=(/self%ptop_8      ,self%pref_8       ,dble(self%rcoef1)/)     
     self%table(1:3,3,1)=(/dble(self%rcoef2),for_char_8           ,0.d0/)

     ! Fill momentum level data
     do k=1,nk+1
        ind=k+skip
        self%table(1:3,ind,1)=(/dble(self%ip1_m(k)),self%a_m_8(k),self%b_m_8(k)/)
     enddo     

     ! Fill thermodynamic level data
     do k=1,nk+2
        ind=k+skip+nk+1
        self%table(1:3,ind,1)=(/dble(self%ip1_t(k)),self%a_t_8(k),self%b_t_8(k)/)
     enddo

     ! Set status and return
     status = VGD_OK
  end function encode_vert_5002

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Decoding functions

  integer function decode_vert_1001(self) result(status)
     type(vgrid_descriptor), intent(inout) :: self  !Vertical descriptor instance
     
     ! Local variables
     integer :: skip,nj,nk,k,ind,error

     ! Set error status
     status = VGD_ERROR

     ! Read header line 1
     self%kind     = nint(self%table(1,1,1))
     self%version  = nint(self%table(2,1,1))
     skip             = nint(self%table(3,1,1))
     
     ! Read header line 2
     error = flip_transfer(self%table(1,2,1),self%ref_name)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: flip_transfer function returned an error code from decode ',error
        return
     endif
     nj=size(self%table,dim=2)
     nk=nj-skip

     ! Allocate and assign level data
     if (associated(self%ip1_m)) deallocate(self%ip1_m)
     allocate(self%ip1_m(nk))
     if (associated(self%a_m_8)) deallocate(self%a_m_8)
     allocate(self%a_m_8(nk))
     if (associated(self%b_m_8)) deallocate(self%b_m_8)
     allocate(self%b_m_8(nk))     

     do k=1,nk
        ind=k+skip
        self%ip1_m(k) = nint(self%table(1,ind,1))
        self%a_m_8(k) =      self%table(2,ind,1)
        self%b_m_8(k) =      self%table(3,ind,1)
     enddo

     ! Set status and return
     status = VGD_OK

  end function decode_vert_1001

  integer function decode_vert_1002(self) result(status)
     type(vgrid_descriptor), intent(inout) :: self  !Vertical descriptor instance
     
     ! Local variables
     integer :: skip,nj,nk,k,ind,error

     ! Set error status
     status = VGD_ERROR

     ! Read header line 1
     self%kind     = nint(self%table(1,1,1))
     self%version  = nint(self%table(2,1,1))
     skip             = nint(self%table(3,1,1))
     
     ! Read header line 2
     self%ptop_8   = self%table(1,2,1)
     error = flip_transfer(self%table(2,2,1),self%ref_name)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: flip_transfer function returned an error code from decode ',error
        return
     endif
     nj=size(self%table,dim=2)
     nk=nj-skip

     ! Allocate and assign level data
     if (associated(self%ip1_m)) deallocate(self%ip1_m)
     allocate(self%ip1_m(nk))
     if (associated(self%a_m_8)) deallocate(self%a_m_8)
     allocate(self%a_m_8(nk))
     if (associated(self%b_m_8)) deallocate(self%b_m_8)
     allocate(self%b_m_8(nk))     

     do k=1,nk
        ind=k+skip
        self%ip1_m(k) = nint(self%table(1,ind,1))
        self%a_m_8(k) =      self%table(2,ind,1)
        self%b_m_8(k) =      self%table(3,ind,1)
     enddo

     ! Set status and return
     status = VGD_OK

  end function decode_vert_1002

  integer function decode_vert_2001(self) result(status)
    type(vgrid_descriptor), intent(inout) :: self  !Vertical descriptor instance

    ! Local variables
    integer :: skip,nj,nk,k,ind
    
    ! Set error status
    status = VGD_ERROR
    
    ! Read header line 1
    self%kind     = nint(self%table(1,1,1))
    self%version  = nint(self%table(2,1,1))
    skip             = nint(self%table(3,1,1))

    nk = size(self%table,dim=2) - skip

    ! Allocate and assign pressure level data
    if (associated(self%ip1_m)) deallocate(self%ip1_m)
    allocate(self%ip1_m(nk))
    if (associated(self%a_m_8)) deallocate(self%a_m_8)
    allocate(self%a_m_8(nk))
    if (associated(self%b_m_8)) deallocate(self%b_m_8)
    allocate(self%b_m_8(nk))

    do k=1,nk
       ind=k+skip
       self%ip1_m(k) = nint(self%table(1,ind,1))
       self%a_m_8(k) =      self%table(2,ind,1)
       self%b_m_8(k) =      self%table(3,ind,1)
    end do

    ! Set status and return
    status = VGD_OK

  end function decode_vert_2001
       
  integer function decode_vert_5001(self) result(status)
     type(vgrid_descriptor), intent(inout) :: self  !Vertical descriptor instance
     
     ! Local variables
     integer :: skip,nj,nk,k,ind,error

     ! Set error status
     status = VGD_ERROR

     ! Read header line 1
     self%kind     = nint(self%table(1,1,1))
     self%version  = nint(self%table(2,1,1))
     skip             = nint(self%table(3,1,1))
     
     ! Read header line 2
     self%ptop_8   = self%table(1,2,1)
     self%pref_8   = self%table(2,2,1)
     self%rcoef1   = real(self%table(3,2,1))

     ! Read header line 3
     error = flip_transfer(self%table(1,3,1),self%ref_name)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: flip_transfer function returned an error code from decode ',error
        return
     endif
     nj=size(self%table,dim=2)
     nk=nj-skip

     ! Allocate and assign level data
     if (associated(self%ip1_m)) deallocate(self%ip1_m)
     allocate(self%ip1_m(nk))
     if (associated(self%a_m_8)) deallocate(self%a_m_8)
     allocate(self%a_m_8(nk))
     if (associated(self%b_m_8)) deallocate(self%b_m_8)
     allocate(self%b_m_8(nk))     

     do k=1,nk
        ind=k+skip
        self%ip1_m(k) = nint(self%table(1,ind,1))
        self%a_m_8(k) =      self%table(2,ind,1)
        self%b_m_8(k) =      self%table(3,ind,1)
     enddo

     ! Set status and return
     status = VGD_OK

  end function decode_vert_5001

  integer function decode_vert_5002(self) result(status)
     type(vgrid_descriptor), intent(inout) :: self  !Vertical descriptor instance
     
     ! Local variables
     integer :: skip,nj,nk,k,ind,error

     ! Set error status
     status = VGD_ERROR

     ! Read header line 1
     self%kind     = nint(self%table(1,1,1))
     self%version  = nint(self%table(2,1,1))
     skip             = nint(self%table(3,1,1))
     
     ! Read header line 2
     self%ptop_8   = self%table(1,2,1)
     self%pref_8   = self%table(2,2,1)
     self%rcoef1   = real(self%table(3,2,1))

     ! Read header line 3
     self%rcoef2   = real(self%table(1,3,1))
     error = flip_transfer(self%table(2,3,1),self%ref_name)
     if (error /= VGD_OK) then
        write(STDERR,*) 'ERROR: flip_transfer function returned an error code from decode ',error
        return
     endif
     nj=size(self%table,dim=2)

     nk=(nj-3-skip)/2

     ! Allocate and assign momentum level data
     if (associated(self%ip1_m)) deallocate(self%ip1_m)
     allocate(self%ip1_m(nk+1))
     if (associated(self%a_m_8)) deallocate(self%a_m_8)
     allocate(self%a_m_8(nk+1))
     if (associated(self%b_m_8)) deallocate(self%b_m_8)
     allocate(self%b_m_8(nk+1))     

     do k=1,nk+1
        ind=k+skip
        self%ip1_m(k) = nint(self%table(1,ind,1))
        self%a_m_8(k) =      self%table(2,ind,1)
        self%b_m_8(k) =      self%table(3,ind,1)
     enddo

     ! Allocate and assign thermodynamic level data
     if (associated(self%ip1_t)) deallocate(self%ip1_t)
     allocate(self%ip1_t(nk+2))
     if (associated(self%a_t_8)) deallocate(self%a_t_8)
     allocate(self%a_t_8(nk+2))
     if (associated(self%b_t_8)) deallocate(self%b_t_8)
     allocate(self%b_t_8(nk+2))     

     do k=1,nk+2
        ind=k+skip+nk+1
        self%ip1_t(k) = nint(self%table(1,ind,1))
        self%a_t_8(k) =      self%table(2,ind,1)
        self%b_t_8(k) =      self%table(3,ind,1)
     enddo     

     ! Set status and return
     status = VGD_OK

  end function decode_vert_5002

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Set and check the vertical code
  
  integer function set_vcode_d(self) result(status)
     ! Compute the internal vertical code from table
     type(vgrid_descriptor), intent(inout) :: self      !Vertical descriptor instance

     ! Local variables
     integer :: kind,version
     
     ! Set error status and check initialization
     status = VGD_ERROR
     if (.not.associated(self%table)) then
        write(STDERR,*) 'ERROR: set_vcode called before constructor'
        return
     endif

     ! Wrap call to integer mangling
     status = get_version_info(self,kind,version)
     if (status /= VGD_OK) then
        write(STDERR,*) 'ERROR: cannot decode table to read kind and version: ',kind,version
        return
     endif
     status = set_vcode(self,kind,version)

     ! Set status and return
     status = VGD_OK
     return
  end function set_vcode_d

  integer function set_vcode_i(self,kind,version) result(status)
     ! Compute the internal vertical code from kind and version
     type(vgrid_descriptor), intent(inout) :: self      !Vertical descriptor instance
     integer, intent(in) :: kind,version                !Kind and version of vertical coord

     ! Set error status
     status = VGD_ERROR

     ! Check for valid entries (version is limited by the mangling equation)
     if (kind > MAX_VKIND .or. kind < 0 .or. version > 999 .or. version < 0) then
        write(STDERR,*) 'ERROR: invalid kind or version: ',kind,version
        return
     endif

     ! Mangle the kind and version information
     self%vcode = kind*1000+version

     ! Set status and return
     status = VGD_OK
     return
  end function set_vcode_i

  integer function get_version_info(self,kind,version) result(status)
    ! Retrieve kind and version information from the table
    type(vgrid_descriptor), intent(in) :: self         !Vertical descriptor instance
    integer, intent(out) :: kind,version               !Kind and version of vertical coord

    ! Set error status
    status = VGD_ERROR
    
    ! Retrieve kind and version information from table
    kind = nint(self%table(1,1,1))
    version = nint(self%table(2,1,1))

    ! Set status and return
    status = VGD_OK
    return
  end function get_version_info

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Descriptor operation support functions

  logical function found_descriptor(self) result(found)
     ! Is the descriptor valid?
     type(vgrid_descriptor), intent(in) :: self         !Vertical descriptor instance
     found = .false.
     if (self%vcode >= 0) then
        found = .true.
     else
        write(STDERR,*) 'WARNING: uninitialized descriptor given to found_descriptor()'
        return
     endif
     return
  end function found_descriptor

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Get/Put support functions
  
  real function get_error(key) result(value)
    ! Write error message and return a missing value
    character(len=*), intent(in) :: key
    write(STDERR,*) 'WARNING: attempt to retrieve invalid key '//trim(key)//' returns VGD_MISSING'
    value = dble(VGD_MISSING)
    return
  end function get_error

  integer function get_allocate_i1d(key,value,len) result(istat)
    ! Allocate space for the result value and report error
    character(len=*), intent(in) :: key
    integer, dimension(:), pointer :: value
    integer, intent(in) :: len
    allocate(value(len),stat=istat)
    if (istat /= 0) then
       write(STDERR,*) 'ERROR: unable to allocate space for '//trim(key)//' request'
    endif
  end function get_allocate_i1d
  
  integer function get_allocate_r1d(key,value,len) result(istat)
    ! Allocate space for the result value and report error
    character(len=*), intent(in) :: key
    real, dimension(:), pointer :: value
    integer, intent(in) :: len
    allocate(value(len),stat=istat)
    if (istat /= 0) then
       write(STDERR,*) 'ERROR: unable to allocate space for '//trim(key)//' request'
    endif
  end function get_allocate_r1d

  integer function get_allocate_r81d(key,value,len) result(istat)
    ! Allocate space for the result value and report error
    character(len=*), intent(in) :: key
    real*8, dimension(:), pointer :: value
    integer, intent(in) :: len
    allocate(value(len),stat=istat)
    if (istat /= 0) then
       write(STDERR,*) 'ERROR: unable to allocate space for '//trim(key)//' request'
    endif
  end function get_allocate_r81d

    integer function get_allocate_r83d(key,value,len) result(istat)
    ! Allocate space for the result value and report error (len is result of 'shape()')
    character(len=*), intent(in) :: key
    real*8, dimension(:,:,:), pointer :: value
    integer, dimension(:), intent(in) :: len
    if (size(len) < 3) then
       write(STDERR,*) 'ERROR: wrong array shape specified for '//trim(key)
       istat = -1
       return
    endif
    allocate(value(len(1),len(2),len(3)),stat=istat)
    if (istat /= 0) then
       write(STDERR,*) 'ERROR: unable to allocate space for '//trim(key)//' request'
    endif
  end function get_allocate_r83d

  integer function put_error(key) result(error)
    character(len=*), intent(in) :: key
    write(STDERR,*) 'WARNING: attempt to set useless value for '//trim(key)
    error = VGD_ERROR
    return
  end function put_error

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Validity inquiry functions

  logical function is_valid(self,element_valid) result(valid)
     ! Check for validity of the element
     type(vgrid_descriptor) :: self          !Vertical descriptor instance
     integer, dimension(:) :: element_valid
     valid = .false.
     if (any(element_valid == self%vcode)) valid = .true.
     return
  end function is_valid

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) FSTD support functions

  integer function fstd_init(self,etiket,ig2,ig3,ig4) result(status)
    ! Initialize common elements of the fstd record
    type(vgrid_descriptor), intent(inout) :: self !Vertical descriptor instance
    character(len=*), intent(in) :: etiket      !Stamp (etiket) entry
    integer, intent(in) :: ig2,ig3,ig4          !IG2-4 values
    status = VGD_ERROR
    self%rec%grtyp='X'
    self%rec%deet=0
    self%rec%npas=0
    self%rec%etiket=trim(etiket)
    self%rec%typvar='X'     
    self%rec%ig1=self%vcode
    self%rec%ig2=ig2
    self%rec%ig3=ig3
    self%rec%ig4=ig4
    status = VGD_OK
  end function fstd_init

  integer function my_fstprm(fstkey,record) result(status)
    ! Use fstprm function to get information about the record
    integer, intent(in) :: fstkey               !Key from FST file record
    type(FSTD_ext) :: record                    !Record information
    integer :: error,ni,nj,nk
    integer, external :: fstprm,fstinf
    real*8 :: nhours
    status = VGD_ERROR
    error=fstprm(fstkey,record%dateo,record%deet,record%npas, &
         record%ni,record%nj,record%nk,record%nbits,record%datyp,record%ip1,record%ip2, &
         record%ip3,record%typvar,record%nomvar,record%etiket,record%grtyp, &
         record%ig1,record%ig2,record%ig3,record%ig4,record%swa, &
         record%lng,record%dltf,record%ubc,record%extra1,record%extra2, &
         record%extra3)
    if (error < 0) then
       write(6,*) 'ERROR: cannot fstprm for fstkey ',fstkey
       return
    end if
    nhours=record%deet*record%npas/3600.d0
    call incdatr(record%datev,record%dateo,nhours)
    status = VGD_OK
  end function my_fstprm

  logical function is_big_endian() result(bend)
    ! Determine the endianness of the machine
    character(len=4) :: str
    select case (transfer(1094861636,str))
    case ('ABCD')
       bend = .true.
    case ('DCBA')
       bend = .false.
    case DEFAULT
       write(STDERR,*) 'WARNING: unable to determine bit ordering in is_big_endian'
       bend = .false.
    end select
    return
  end function is_big_endian

  integer function flip_transfer_r8(str,val_out) result(status)
    ! Convert string to a little-endian 8-byte real
    character(len=*), intent(in) :: str                 !string to convert
    real*8, intent(out) :: val_out                      !8-byte real for output
    integer :: i,cnt
    character(len=8) :: str_cvt
    status = VGD_ERROR; val_out = 0.d0
    if (len_trim(str) > len(str_cvt)) then
       write(STDERR,*) 'ERROR: string length to flip_transfer (',len_trim(str),') exceeds limit: ',len(str)
       return
    endif
    if (is_big_endian()) then
       cnt = 1
       do i=len(str_cvt),1,-1
          if (cnt <= len_trim(str)) then
             str_cvt(i:i) = str(cnt:cnt)
             cnt = cnt+1
          else
             str_cvt(i:i) = ' '
          endif
       enddo
    else
       str_cvt = str
    endif
    val_out = transfer(str_cvt,val_out)
    status = VGD_OK
    return
  end function flip_transfer_r8

  integer function flip_transfer_char(val,str_out) result(status)
    ! Convert a little-endian 8-byte real to a string
    real*8, intent(in) :: val                           !8-byte real to convert
    character(len=*), intent(out) :: str_out            !string for output
    integer :: i,cnt
    character(len=8) :: str_cvt
    logical :: overflow
    status = VGD_ERROR; str_out = ''
    str_cvt = transfer(val,str_cvt)
    if (is_big_endian()) then
       cnt = 1; overflow = .false.
       do i=len(str_cvt),1,-1
          if (cnt <= len(str_out)) then
             str_out(cnt:cnt) = str_cvt(i:i)
             cnt = cnt+1
          else
             if (ichar(str_cvt(i:i)) > 32) overflow = .true.
          endif
       enddo
    else
       str_out = str_cvt
    endif
    if (overflow) then
       write(STDERR,*) 'ERROR: string length to flip_transfer (',len(str_out),') is insufficient: ',len_trim(str_cvt)
       return
    endif
    status = VGD_OK
    return
  end function flip_transfer_char

!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! (PRIVATE) Pressure computation functions

  integer function compute_pressure_1001(self,sfc_field,ip1_list,levels,in_log) result(status)
    ! Compute pressure for all levels specified in ip1_list
    type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
    real, dimension(:,:), intent(in) :: sfc_field       !Surface field reference for coordinate
    integer, dimension(:), intent(in) :: ip1_list       !List of IP1 levels to calculate on
    real, dimension(:,:,:), pointer  :: levels          !Physical level values
    logical, intent(in) :: in_log                       !Compute level values in ln()

    ! Internal variables
    integer :: i,j,error,nk
    real*8, dimension(size(sfc_field,dim=1),size(sfc_field,dim=2)) :: s_8
    real*8, dimension(size(ip1_list)) :: aa_8,bb_8
    logical :: found,my_in_log

    ! Set error status
    status = VGD_ERROR

    ! Set size of output
    nk = size(ip1_list)
    
    ! Find ip1 values
    do i=1,nk
       found = .false.
       do j=1,size(self%ip1_m)
          if (self%ip1_m(j) == ip1_list(i)) then
             found = .true.
             aa_8(i) = self%a_m_8(j)
             bb_8(i) = self%b_m_8(j)
             exit
          endif
       enddo
       if (.not.found) then
          write(STDERR,*) 'ERROR: cannot find ip1 ',ip1_list(i),' in compute_pressure_1001'
          return
       endif
    enddo

    ! Compute pressure
    do i=1,nk
       levels(:,:,i) = aa_8(i) + bb_8(i)*sfc_field
    enddo
    if (in_log) levels = log(levels)

    ! Set status and return
    status = VGD_OK
    return
 end function compute_pressure_1001

  integer function compute_pressure_1002(self,sfc_field,ip1_list,levels,in_log) result(status)
    ! Compute pressure for all levels specified in ip1_list
    type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
    real, dimension(:,:), intent(in) :: sfc_field       !Surface field reference for coordinate
    integer, dimension(:), intent(in) :: ip1_list       !List of IP1 levels to calculate on
    real, dimension(:,:,:), pointer  :: levels          !Physical level values
    logical, intent(in) :: in_log                       !Compute level values in ln()

    ! Internal variables
    integer :: i,j,error,nk
    real*8, dimension(size(sfc_field,dim=1),size(sfc_field,dim=2)) :: s_8
    real*8, dimension(size(ip1_list)) :: aa_8,bb_8
    logical :: found,my_in_log

    ! Set error status
    status = VGD_ERROR

    ! Set size of output
    nk = size(ip1_list)
    
    ! Find ip1 values
    do i=1,nk
       found = .false.
       do j=1,size(self%ip1_m)
          if (self%ip1_m(j) == ip1_list(i)) then
             found = .true.
             aa_8(i) = self%a_m_8(j)
             bb_8(i) = self%b_m_8(j)
             exit
          endif
       enddo
       if (.not.found) then
          write(STDERR,*) 'ERROR: cannot find ip1 ',ip1_list(i),' in compute_pressure_1002'
          return
       endif
    enddo

    ! Compute pressure
    do i=1,nk
       levels(:,:,i) = aa_8(i) + bb_8(i)*sfc_field
    enddo
    if (in_log) levels = log(levels)

    ! Set status and return
    status = VGD_OK
    return
 end function compute_pressure_1002

  integer function compute_pressure_2001(self,ip1_list,levels,in_log) result(status)
    ! Compute pressure for all levels specified in ip1_list
    type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
    integer, dimension(:), intent(in) :: ip1_list       !List of IP1 levels to calculate on
    real, dimension(:,:,:), pointer  :: levels          !Physical level values
    logical, intent(in) :: in_log                       !Compute level values in ln()

    ! Local variables
    integer :: i,j,nk
    real*8, dimension(size(ip1_list)) :: aa_8,bb_8
    logical :: found
    
    ! Set error status
    status = VGD_ERROR
    
    ! Set size of output
    nk = size(ip1_list)

    ! Find ip1 values
    do i=1,nk
       found = .false.
       do j=1,size(self%ip1_m)
          if (self%ip1_m(j) == ip1_list(i)) then
             found = .true.
             aa_8(i) = self%a_m_8(j)
             bb_8(i) = self%b_m_8(j)
          endif
       enddo
       if (.not.found) then
          write(STDERR,*) 'ERROR: cannot find ip1 ',ip1_list(i),' in compute_pressure_2001'
          return
       endif
    enddo

    ! Compute pressure
    do i=1,nk
       levels(:,:,i) = aa_8(i) + 0.d0*bb_8(i)
    enddo
    if (in_log) levels = log(levels)

    ! Set status and return
    status = VGD_OK
    return

  end function compute_pressure_2001

  integer function compute_pressure_5001(self,sfc_field,ip1_list,levels,in_log) result(status)
    ! Compute pressure for all levels specified in ip1_list
    type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
    real, dimension(:,:), intent(in) :: sfc_field       !Surface field reference for coordinate
    integer, dimension(:), intent(in) :: ip1_list       !List of IP1 levels to calculate on
    real, dimension(:,:,:), pointer  :: levels          !Physical level values
    logical, intent(in) :: in_log                       !Compute level values in ln()

    ! Internal variables
    integer :: i,j,error,nk
    real*8, dimension(size(sfc_field,dim=1),size(sfc_field,dim=2)) :: s_8
    real*8, dimension(size(ip1_list)) :: aa_8,bb_8
    logical :: found,my_in_log

    ! Set error status
    status = VGD_ERROR

    ! Set size of output
    nk = size(ip1_list)
    
    ! Find ip1 values
    do i=1,nk
       found = .false.
       do j=1,size(self%ip1_m)
          if (self%ip1_m(j) == ip1_list(i)) then
             found = .true.
             aa_8(i) = self%a_m_8(j)
             bb_8(i) = self%b_m_8(j)
             exit
          endif
       enddo
       if (.not.found) then
          write(STDERR,*) 'ERROR: cannot find ip1 ',ip1_list(i),' in compute_pressure_5001'
          return
       endif
    enddo

    ! Compute pressure
    do i=1,nk
       levels(:,:,i) = aa_8(i) + bb_8(i)*sfc_field
    enddo
    if (in_log) levels = log(levels)

    ! Set status and return
    status = VGD_OK
    return
 end function compute_pressure_5001

  integer function compute_pressure_5002(self,sfc_field,ip1_list,levels,in_log) result(status)
    ! Compute pressure for all levels specified in ip1_list
    type(vgrid_descriptor), intent(in) :: self          !Vertical descriptor instance
    real, dimension(:,:), intent(in) :: sfc_field       !Surface field reference for coordinate
    integer, dimension(:), intent(in) :: ip1_list       !List of IP1 levels to calculate on
    real, dimension(:,:,:), pointer  :: levels          !Physical level values
    logical, intent(in) :: in_log                       !Compute level values in ln()

    ! Internal variables
    integer :: i,j,error,nk
    real*8, dimension(size(sfc_field,dim=1),size(sfc_field,dim=2)) :: s_8
    real*8, dimension(size(ip1_list)) :: aa_8,bb_8
    logical :: found,my_in_log

    ! Set error status
    status = VGD_ERROR

    ! Set size of output
    nk = size(ip1_list)
    
    ! Find ip1 values
    do i=1,nk
       found = .false.
       do j=1,size(self%ip1_m)
          if (self%ip1_m(j) == ip1_list(i)) then
             found = .true.
             aa_8(i) = self%a_m_8(j)
             bb_8(i) = self%b_m_8(j)
             exit
          endif
       enddo
       if (.not.found) then
          do j=1,size(self%ip1_t)
             if (self%ip1_t(j) == ip1_list(i)) then
                found = .true.
                aa_8(i) = self%a_t_8(j)
                bb_8(i) = self%b_t_8(j)
                exit
             endif
          enddo
       endif
       if (.not.found) then
          write(STDERR,*) 'ERROR: cannot find ip1 ',ip1_list(i),' in compute_pressure_5002'
          return
       endif
    enddo

    ! Compute pressure
    s_8 = log(dble(sfc_field)/self%pref_8)
    do i=1,nk
       levels(:,:,i) = aa_8(i) + bb_8(i)*s_8
    enddo
    if (.not.in_log) levels = exp(levels)

    ! Set status and return
    status = VGD_OK
    return
 end function compute_pressure_5002

end module vGrid_Descriptors
